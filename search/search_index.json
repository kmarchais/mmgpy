{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mmgpy","text":"<p>Python bindings for the MMG remeshing library.</p> <p>Get Started  API Reference </p>"},{"location":"#features","title":"Features","text":"3D Volume Meshing Tetrahedral remeshing 2D Meshing Triangular remeshing for planar domains Surface Meshing 3D surface remeshing and optimization Local Sizing Sphere, box, cylinder, and point-based refinement Anisotropic Metrics Custom metric tensors for directional adaptation Level-Set Extract isosurfaces from implicit functions Lagrangian Motion Remesh while preserving displacement fields PyVista Integration Seamless conversion for visualization 40+ File Formats VTK, STL, OBJ, GMSH, and more via meshio"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import mmgpy\n\n# Load a mesh from any supported format\nmesh = mmgpy.read(\"input.mesh\")\n\n# Remesh with target edge size\nresult = mesh.remesh(hmax=0.1)\nprint(f\"Quality: {result.quality_mean_before:.2f} \u2192 {result.quality_mean_after:.2f}\")\n\n# Save the result\nmesh.save(\"output.vtk\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"pipuv <pre><code>pip install mmgpy\n</code></pre> <pre><code>uv pip install mmgpy\n# or: uv add mmgpy (project dependency)\n# or: uv tool install mmgpy (mmg2d_O3, mmg3d_O3, mmgs_O3 globally)\n</code></pre>"},{"location":"#gallery","title":"Gallery","text":"<p> Surface remeshing of a mechanical part</p> <p> Smooth surface mesh optimization</p> <p> 3D volumetric mesh quality improvement</p>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Quick Start \u2014 Get started in 5 minutes</li> <li>Tutorials \u2014 Step-by-step guides</li> <li>API Reference \u2014 Complete documentation</li> <li>Examples \u2014 Real-world use cases</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to mmgpy are documented here.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Comprehensive API documentation site with MkDocs</li> <li>Tutorials for common workflows</li> <li>Examples gallery</li> </ul>"},{"location":"changelog/#040-in-development","title":"[0.4.0] - In Development","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>mesh.validate()</code> method with comprehensive quality checks (#88)</li> <li><code>RemeshResult</code> dataclass with detailed statistics from remeshing operations (#87)</li> <li>Unified <code>Mesh</code> class with auto-detection and <code>mmgpy.read()</code> function (#85)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Remeshing methods now return <code>RemeshResult</code> instead of <code>bool</code></li> </ul>"},{"location":"changelog/#030-2024","title":"[0.3.0] - 2024","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Local sizing parameters API for per-region mesh control (#81)</li> <li><code>set_size_sphere()</code>, <code>set_size_box()</code>, <code>set_size_cylinder()</code>, <code>set_size_from_point()</code></li> <li>Typed options dataclasses: <code>Mmg3DOptions</code>, <code>Mmg2DOptions</code>, <code>MmgSOptions</code> (#70)</li> <li>Factory methods: <code>.fine()</code>, <code>.coarse()</code>, <code>.optimize_only()</code></li> <li>PyVista integration for mesh conversion (#69)</li> <li><code>mesh.to_pyvista()</code> and <code>mmgpy.from_pyvista()</code></li> <li>Level-set discretization API (#68)</li> <li><code>mesh.remesh_levelset(levelset_field)</code></li> <li>Topology query methods (#67)</li> <li><code>get_adjacent_elements()</code>, <code>get_vertex_neighbors()</code></li> <li>Element attributes API (#66)</li> <li><code>set_corners()</code>, <code>set_required_vertices()</code>, <code>set_ridge_edges()</code></li> <li>Logging module with Rich integration (#65)</li> <li><code>enable_debug()</code>, <code>set_log_level()</code>, <code>rich_progress()</code></li> <li>Lagrangian motion remeshing (#64)</li> <li><code>mesh.remesh_lagrangian(displacement)</code></li> <li>Field storage via <code>__getitem__</code>/<code>__setitem__</code> (#63)</li> <li><code>mesh[\"temperature\"] = values</code></li> <li>Convenience remeshing methods (#62)</li> <li><code>remesh_optimize()</code>, <code>remesh_uniform(size)</code></li> <li>Bulk data operations for all mesh types (#61)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Updated VTK to 9.5.2 (#82)</li> <li>Improved wheel size optimization</li> </ul>"},{"location":"changelog/#020-2024","title":"[0.2.0] - 2024","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Initial PyPI release</li> <li>Pre-built wheels for Windows, macOS, and Linux</li> <li>Support for Python 3.10 - 3.13</li> <li><code>MmgMesh3D</code>, <code>MmgMesh2D</code>, <code>MmgMeshS</code> classes</li> <li>File-based remeshing: <code>mmg3d.remesh()</code>, <code>mmg2d.remesh()</code>, <code>mmgs.remesh()</code></li> <li>Bundled MMG executables</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>RPATH handling on macOS and Linux</li> <li>DLL loading on Windows</li> </ul>"},{"location":"changelog/#010-2024","title":"[0.1.0] - 2024","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial release</li> <li>Basic pybind11 bindings for MMG library</li> <li>CMake build system with scikit-build-core</li> </ul>"},{"location":"changelog/#version-numbering","title":"Version Numbering","text":"<p>mmgpy follows Semantic Versioning:</p> <ul> <li>MAJOR: Breaking API changes</li> <li>MINOR: New features, backward compatible</li> <li>PATCH: Bug fixes, backward compatible</li> </ul>"},{"location":"changelog/#links","title":"Links","text":"<ul> <li>GitHub Releases</li> <li>PyPI</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed API documentation for all public classes and functions in mmgpy.</p>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#core-classes","title":"Core Classes","text":"Class Description <code>Mesh</code> Unified mesh wrapper with auto-detection <code>MmgMesh3D</code> 3D tetrahedral volume mesh <code>MmgMesh2D</code> 2D triangular planar mesh <code>MmgMeshS</code> 3D triangular surface mesh"},{"location":"api/#options-classes","title":"Options Classes","text":"Class Description <code>Mmg3DOptions</code> Options for 3D remeshing <code>Mmg2DOptions</code> Options for 2D remeshing <code>MmgSOptions</code> Options for surface remeshing"},{"location":"api/#result-classes","title":"Result Classes","text":"Class Description <code>RemeshResult</code> Remeshing operation statistics <code>ValidationReport</code> Mesh validation results <code>QualityStats</code> Element quality statistics"},{"location":"api/#sizing-constraints","title":"Sizing Constraints","text":"Class Description <code>SphereSize</code> Spherical refinement region <code>BoxSize</code> Box refinement region <code>CylinderSize</code> Cylindrical refinement region <code>PointSize</code> Distance-based sizing"},{"location":"api/#io-functions","title":"I/O Functions","text":"Function Description <code>read()</code> Load mesh from file or PyVista object <code>from_pyvista()</code> Create mesh from PyVista <code>to_pyvista()</code> Convert mesh to PyVista"},{"location":"api/#modules","title":"Modules","text":"Module Description <code>mmgpy.metrics</code> Metric tensor operations <code>mmgpy.lagrangian</code> Lagrangian mesh motion <code>mmgpy.sizing</code> Sizing constraint classes"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>mmgpy\n\u251c\u2500\u2500 Core Classes\n\u2502   \u251c\u2500\u2500 Mesh              # Unified mesh class\n\u2502   \u251c\u2500\u2500 MmgMesh3D         # 3D volume mesh\n\u2502   \u251c\u2500\u2500 MmgMesh2D         # 2D planar mesh\n\u2502   \u2514\u2500\u2500 MmgMeshS          # 3D surface mesh\n\u2502\n\u251c\u2500\u2500 Options\n\u2502   \u251c\u2500\u2500 Mmg3DOptions      # 3D options\n\u2502   \u251c\u2500\u2500 Mmg2DOptions      # 2D options\n\u2502   \u2514\u2500\u2500 MmgSOptions       # Surface options\n\u2502\n\u251c\u2500\u2500 Results &amp; Validation\n\u2502   \u251c\u2500\u2500 RemeshResult      # Operation statistics\n\u2502   \u251c\u2500\u2500 ValidationReport  # Validation results\n\u2502   \u251c\u2500\u2500 ValidationIssue   # Individual issues\n\u2502   \u2514\u2500\u2500 QualityStats      # Quality metrics\n\u2502\n\u251c\u2500\u2500 Sizing\n\u2502   \u251c\u2500\u2500 SphereSize        # Spherical region\n\u2502   \u251c\u2500\u2500 BoxSize           # Box region\n\u2502   \u251c\u2500\u2500 CylinderSize      # Cylinder region\n\u2502   \u2514\u2500\u2500 PointSize         # Point-based sizing\n\u2502\n\u251c\u2500\u2500 I/O Functions\n\u2502   \u251c\u2500\u2500 read()            # Load mesh\n\u2502   \u251c\u2500\u2500 from_pyvista()    # From PyVista\n\u2502   \u2514\u2500\u2500 to_pyvista()      # To PyVista\n\u2502\n\u251c\u2500\u2500 mmgpy.metrics         # Metric operations\n\u2502   \u251c\u2500\u2500 create_isotropic_metric()\n\u2502   \u251c\u2500\u2500 create_anisotropic_metric()\n\u2502   \u2514\u2500\u2500 intersect_metrics()\n\u2502\n\u2514\u2500\u2500 mmgpy.lagrangian      # Mesh motion\n    \u251c\u2500\u2500 move_mesh()\n    \u2514\u2500\u2500 propagate_displacement()\n</code></pre>"},{"location":"api/#basic-usage-pattern","title":"Basic Usage Pattern","text":"<pre><code>import mmgpy\n\n# Load mesh\nmesh = mmgpy.read(\"input.mesh\")\n\n# Configure options\nopts = mmgpy.Mmg3DOptions(hmax=0.1)\n\n# Remesh\nresult = mesh.remesh(opts)\n\n# Validate\nreport = mesh.validate(detailed=True)\n\n# Save\nmesh.save(\"output.vtk\")\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All public APIs are fully typed. Use with a type-aware IDE for autocomplete:</p> <pre><code>from mmgpy import MmgMesh3D, Mmg3DOptions, RemeshResult\n\nmesh: MmgMesh3D = MmgMesh3D(\"input.mesh\")\nopts: Mmg3DOptions = Mmg3DOptions(hmax=0.1)\nresult: RemeshResult = mesh.remesh(opts)\n</code></pre>"},{"location":"api/#version-information","title":"Version Information","text":"<pre><code>import mmgpy\n\nprint(f\"mmgpy version: {mmgpy.__version__}\")\nprint(f\"MMG version: {mmgpy.MMG_VERSION}\")\n</code></pre>"},{"location":"api/io/","title":"I/O Functions","text":"<p>This page documents the input/output functions for loading and saving meshes.</p>"},{"location":"api/io/#reading-meshes","title":"Reading Meshes","text":"<p>options: show_root_heading: true</p>"},{"location":"api/io/#mmgpy.read","title":"mmgpy.read","text":"<pre><code>read(\n    source: str | Path | UnstructuredGrid | PolyData, mesh_kind: MeshKind | None = None\n) -&gt; Mesh\n</code></pre> <p>Read a mesh from a file or PyVista object.</p> <p>This function provides unified mesh loading from any format supported by meshio (40+ formats including VTK, Gmsh, STL, OBJ, etc.) or directly from PyVista mesh objects.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>str | Path | UnstructuredGrid | PolyData</code>)           \u2013            <p>File path (str or Path) or PyVista mesh object.</p> </li> <li> <code>mesh_kind</code>               (<code>MeshKind | None</code>, default:                   <code>None</code> )           \u2013            <p>Force a specific mesh kind instead of auto-detection. - MeshKind.TETRAHEDRAL: 3D volumetric mesh - MeshKind.TRIANGULAR_2D: 2D planar mesh - MeshKind.TRIANGULAR_SURFACE: 3D surface mesh - None: Auto-detect based on element types and coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Mesh</code>           \u2013            <p>A Mesh instance with the appropriate kind.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If mesh kind cannot be determined or file cannot be read.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If source type is not supported.</p> </li> </ul> Auto-detection logic <ul> <li>Has tetrahedra \u2192 TETRAHEDRAL</li> <li>Has triangles + 3D coords \u2192 TRIANGULAR_SURFACE</li> <li>Has triangles + 2D coords (or z\u22480) \u2192 TRIANGULAR_2D</li> </ul> <p>Supported file formats (via meshio):     - VTK: .vtk, .vtu, .vtp     - Gmsh: .msh     - Medit: .mesh     - STL: .stl     - OBJ: .obj     - PLY: .ply     - And many more...</p> Example <p>import mmgpy</p>"},{"location":"api/io/#mmgpy.read--auto-detect-mesh-kind-from-file","title":"Auto-detect mesh kind from file","text":"<p>mesh = mmgpy.read(\"tetra_mesh.vtk\") mesh.kind  # MeshKind.TETRAHEDRAL</p>"},{"location":"api/io/#mmgpy.read--force-specific-mesh-kind","title":"Force specific mesh kind","text":"<p>mesh = mmgpy.read(\"mesh.vtk\", mesh_kind=MeshKind.TRIANGULAR_SURFACE)</p>"},{"location":"api/io/#mmgpy.read--read-from-pyvista-object","title":"Read from PyVista object","text":"<p>import pyvista as pv grid = pv.read(\"mesh.vtk\") mesh = mmgpy.read(grid)</p>"},{"location":"api/io/#supported-formats","title":"Supported Formats","text":"<p>mmgpy supports 40+ file formats via meshio:</p> Format Extensions Notes MMG native <code>.mesh</code>, <code>.meshb</code> Recommended for MMG VTK Legacy <code>.vtk</code> Universal, ParaView compatible VTK XML <code>.vtu</code>, <code>.vtp</code> Modern VTK format STL <code>.stl</code> Surface meshes only OBJ <code>.obj</code> Surface meshes only PLY <code>.ply</code> Point cloud / mesh GMSH <code>.msh</code> Popular for FEM Abaqus <code>.inp</code> FEM format CGNS <code>.cgns</code> CFD format Exodus II <code>.e</code>, <code>.exo</code> Sandia format ANSYS <code>.ansys</code> FEM format MED <code>.med</code> Salome format And many more... See meshio documentation"},{"location":"api/io/#usage","title":"Usage","text":"<pre><code>import mmgpy\n\n# Auto-detect format from extension\nmesh = mmgpy.read(\"input.mesh\")\nmesh = mmgpy.read(\"input.vtk\")\nmesh = mmgpy.read(\"input.stl\")\n\n# Returns unified Mesh object\nprint(f\"Type: {mesh.kind}\")  # MeshKind.TETRAHEDRAL, etc.\n</code></pre>"},{"location":"api/io/#pyvista-conversion","title":"PyVista Conversion","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/io/#mmgpy.from_pyvista","title":"mmgpy.from_pyvista","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid | PolyData, mesh_type: type[MmgMesh3D]\n) -&gt; MmgMesh3D\n</code></pre><pre><code>from_pyvista(\n    mesh: UnstructuredGrid | PolyData, mesh_type: type[MmgMesh2D]\n) -&gt; MmgMesh2D\n</code></pre><pre><code>from_pyvista(mesh: UnstructuredGrid | PolyData, mesh_type: type[MmgMeshS]) -&gt; MmgMeshS\n</code></pre><pre><code>from_pyvista(\n    mesh: UnstructuredGrid | PolyData, mesh_type: None = None\n) -&gt; MmgMesh3D | MmgMesh2D | MmgMeshS\n</code></pre> <pre><code>from_pyvista(\n    mesh: UnstructuredGrid | PolyData,\n    mesh_type: type[MmgMesh3D | MmgMesh2D | MmgMeshS] | None = None,\n) -&gt; MmgMesh3D | MmgMesh2D | MmgMeshS\n</code></pre> <p>Convert a PyVista mesh to an mmgpy mesh.</p> <p>Parameters:</p> <ul> <li> <code>mesh</code>               (<code>UnstructuredGrid | PolyData</code>)           \u2013            <p>PyVista mesh (UnstructuredGrid or PolyData).</p> </li> <li> <code>mesh_type</code>               (<code>type[MmgMesh3D | MmgMesh2D | MmgMeshS] | None</code>, default:                   <code>None</code> )           \u2013            <p>Target mesh class. If None, auto-detects based on: - UnstructuredGrid with tetrahedra \u2192 MmgMesh3D - PolyData with 2D points (z\u22480) \u2192 MmgMesh2D - PolyData with 3D points \u2192 MmgMeshS</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MmgMesh3D | MmgMesh2D | MmgMeshS</code>           \u2013            <p>The appropriate mmgpy mesh instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If mesh type cannot be determined or is incompatible.</p> </li> </ul> Note <p>When auto-detecting mesh type for PolyData, a mesh is considered 2D (and converted to MmgMesh2D) if all z-coordinates are within 1e-8 of zero. For thin 3D meshes near z=0, explicitly specify <code>mesh_type=MmgMeshS</code>.</p> Example <p>import pyvista as pv from mmgpy import from_pyvista, MmgMeshS</p>"},{"location":"api/io/#mmgpy.from_pyvista--auto-detect-mesh-type","title":"Auto-detect mesh type","text":"<p>grid = pv.read(\"tetra_mesh.vtk\") mesh3d = from_pyvista(grid)</p>"},{"location":"api/io/#mmgpy.from_pyvista--explicit-mesh-type-for-thin-3d-surfaces","title":"Explicit mesh type for thin 3D surfaces","text":"<p>surface = pv.read(\"surface.stl\") mesh_s = from_pyvista(surface, MmgMeshS)</p>"},{"location":"api/io/#mmgpy.to_pyvista","title":"mmgpy.to_pyvista","text":"<pre><code>to_pyvista(mesh: MmgMesh3D, *, include_refs: bool = True) -&gt; pv.UnstructuredGrid\n</code></pre><pre><code>to_pyvista(mesh: MmgMesh2D, *, include_refs: bool = True) -&gt; pv.PolyData\n</code></pre><pre><code>to_pyvista(mesh: MmgMeshS, *, include_refs: bool = True) -&gt; pv.PolyData\n</code></pre> <pre><code>to_pyvista(\n    mesh: MmgMesh3D | MmgMesh2D | MmgMeshS, *, include_refs: bool = True\n) -&gt; pv.UnstructuredGrid | pv.PolyData\n</code></pre> <p>Convert an mmgpy mesh to a PyVista mesh.</p> <p>Parameters:</p> <ul> <li> <code>mesh</code>               (<code>MmgMesh3D | MmgMesh2D | MmgMeshS</code>)           \u2013            <p>mmgpy mesh instance (MmgMesh3D, MmgMesh2D, or MmgMeshS).</p> </li> <li> <code>include_refs</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, include element references as cell_data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UnstructuredGrid | PolyData</code>           \u2013            <p>PyVista mesh: - MmgMesh3D \u2192 UnstructuredGrid with tetrahedra - MmgMesh2D \u2192 PolyData with triangular faces (z=0) - MmgMeshS \u2192 PolyData with triangular faces</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If mesh is not an mmgpy mesh type.</p> </li> </ul> Example <p>from mmgpy import MmgMesh3D, to_pyvista</p> <p>mesh = MmgMesh3D(vertices, elements) mesh.remesh(hmax=0.1) grid = to_pyvista(mesh) grid.plot()</p>"},{"location":"api/io/#from-pyvista","title":"From PyVista","text":"<pre><code>import mmgpy\nimport pyvista as pv\n\n# Create PyVista geometry\nsphere = pv.Sphere(radius=1.0)\n\n# Convert to surface mesh\nmesh = mmgpy.from_pyvista(sphere, mesh_type=\"surface\")\n\n# For volumetric meshes (needs tetrahedral cells)\nvolume = pv.Box().triangulate().delaunay_3d()\nmesh_3d = mmgpy.from_pyvista(volume, mesh_type=\"3d\")\n\n# For 2D meshes\nplane = pv.Plane()\nmesh_2d = mmgpy.from_pyvista(plane, mesh_type=\"2d\")\n</code></pre>"},{"location":"api/io/#to-pyvista","title":"To PyVista","text":"<pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Convert to PyVista\npv_mesh = mesh.to_pyvista()\n\n# Or using function\npv_mesh = mmgpy.to_pyvista(mesh)\n\n# Visualize\npv_mesh.plot(show_edges=True)\n</code></pre>"},{"location":"api/io/#saving-meshes","title":"Saving Meshes","text":"<p>Meshes are saved using the <code>save()</code> method:</p> <pre><code>mesh.save(\"output.mesh\")  # MMG native\nmesh.save(\"output.vtk\")   # VTK format\nmesh.save(\"output.stl\")   # STL (surface only)\n</code></pre> <p>Format is inferred from the file extension.</p>"},{"location":"api/io/#direct-class-loading","title":"Direct Class Loading","text":"<p>Each mesh class can also load from files directly:</p> <pre><code>import mmgpy\n\n# 3D mesh\nmesh_3d = mmgpy.MmgMesh3D(\"volume.mesh\")\n\n# 2D mesh\nmesh_2d = mmgpy.MmgMesh2D(\"planar.mesh\")\n\n# Surface mesh\nmesh_s = mmgpy.MmgMeshS(\"surface.stl\")\n</code></pre>"},{"location":"api/io/#complete-example","title":"Complete Example","text":"<pre><code>import mmgpy\nimport pyvista as pv\n\n# Load from file\nmesh = mmgpy.read(\"input.mesh\")\nprint(f\"Loaded {mesh.kind} mesh\")\n\n# Remesh\nmesh.remesh(hmax=0.1)\n\n# Save to different formats\nmesh.save(\"output.mesh\")   # MMG native (fast)\nmesh.save(\"output.vtk\")    # For ParaView\nmesh.save(\"output.vtu\")    # VTK XML format\n\n# Convert to PyVista for visualization\npv_mesh = mesh.to_pyvista()\npv_mesh.save(\"output_pv.vtk\")\n\n# Or create from PyVista\ntorus = pv.ParametricTorus()\ntorus_mesh = mmgpy.from_pyvista(torus, mesh_type=\"surface\")\ntorus_mesh.remesh(hmax=0.1)\ntorus_mesh.save(\"torus.mesh\")\n</code></pre>"},{"location":"api/io/#tips","title":"Tips","text":"<ol> <li>MMG native format: Use <code>.mesh</code> for fastest I/O with MMG</li> <li>VTK for visualization: Use <code>.vtk</code> or <code>.vtu</code> for ParaView</li> <li>Surface formats: STL and OBJ are surface-only</li> <li>Binary formats: Some formats support binary (faster, smaller)</li> <li>Field data: Most formats preserve scalar/vector fields</li> </ol>"},{"location":"api/lagrangian/","title":"Lagrangian Motion","text":"<p>This page documents the Lagrangian mesh motion functions in the <code>mmgpy.lagrangian</code> module.</p>"},{"location":"api/lagrangian/#overview","title":"Overview","text":"<p>Lagrangian remeshing handles moving meshes by:</p> <ol> <li>Applying a displacement field to the mesh</li> <li>Remeshing to maintain quality</li> <li>Preserving boundary conditions</li> </ol> <p>This is useful for:</p> <ul> <li>Moving mesh simulations</li> <li>Shape optimization</li> <li>Fluid-structure interaction</li> <li>Morphing between shapes</li> </ul>"},{"location":"api/lagrangian/#functions","title":"Functions","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/lagrangian/#mmgpy.move_mesh","title":"mmgpy.move_mesh","text":"<pre><code>move_mesh(\n    mesh: MmgMesh2D | MmgMesh3D | MmgMeshS,\n    displacement: NDArray[float64],\n    *,\n    boundary_mask: NDArray[bool_] | None = None,\n    propagate: bool = True,\n    n_steps: int = 1,\n    **remesh_options: float | bool | None,\n) -&gt; None\n</code></pre> <p>Move mesh vertices by displacement and remesh to maintain quality.</p> <p>This is a pure Python implementation of Lagrangian motion that works without the ELAS library. For large displacements, consider using multiple steps (n_steps &gt; 1) to avoid mesh inversion.</p> <p>Parameters:</p> <ul> <li> <code>mesh</code>               (<code>MmgMesh2D | MmgMesh3D | MmgMeshS</code>)           \u2013            <p>MmgMesh2D, MmgMesh3D, or MmgMeshS mesh object.</p> </li> <li> <code>displacement</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Nxdim array of displacement vectors for each vertex. If boundary_mask is provided and propagate=True, only boundary values need to be correct; interior values will be computed.</p> </li> <li> <code>boundary_mask</code>               (<code>NDArray[bool_] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional boolean array indicating which vertices have prescribed displacement. If None, all vertices are treated as having prescribed displacement (no propagation needed).</p> </li> <li> <code>propagate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True and boundary_mask is provided, propagate boundary displacement to interior using Laplacian smoothing.</p> </li> <li> <code>n_steps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of incremental steps to apply the displacement. Use more steps for large displacements to avoid mesh inversion.</p> </li> <li> <code>**remesh_options</code>               (<code>float | bool | None</code>, default:                   <code>{}</code> )           \u2013            <p>Options passed to mesh.remesh() (hmax, hmin, etc.).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If displacement dimensions don't match mesh.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If remeshing fails.</p> </li> </ul>"},{"location":"api/lagrangian/#mmgpy.propagate_displacement","title":"mmgpy.propagate_displacement","text":"<pre><code>propagate_displacement(\n    vertices: NDArray[float64],\n    elements: NDArray[int32],\n    boundary_mask: NDArray[bool_],\n    boundary_displacement: NDArray[float64],\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Propagate displacement from boundary to interior using Laplacian smoothing.</p> <p>Solves the Laplace equation nabla^2 u = 0 with Dirichlet boundary conditions u = boundary_displacement on the boundary. This produces a smooth displacement field that transitions from boundary values to interior.</p> <p>The complexity is O(n) for building the matrix and typically O(n^1.5) for solving due to the sparse structure.</p> <p>Parameters:</p> <ul> <li> <code>vertices</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Nx2 or Nx3 array of vertex coordinates.</p> </li> <li> <code>elements</code>               (<code>NDArray[int32]</code>)           \u2013            <p>Mx(nodes_per_element) array of element connectivity.</p> </li> <li> <code>boundary_mask</code>               (<code>NDArray[bool_]</code>)           \u2013            <p>N boolean array, True for vertices with prescribed displacement.</p> </li> <li> <code>boundary_displacement</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Nxdim array of displacement vectors. Only values at boundary vertices (where boundary_mask is True) are used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[float64]</code>           \u2013            <p>Nxdim array of displacement for all vertices.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If array dimensions don't match.</p> </li> </ul>"},{"location":"api/lagrangian/#mmgpy.detect_boundary_vertices","title":"mmgpy.detect_boundary_vertices","text":"<pre><code>detect_boundary_vertices(mesh: MmgMesh2D | MmgMesh3D | MmgMeshS) -&gt; NDArray[np.bool_]\n</code></pre> <p>Detect boundary vertices in a mesh.</p> <p>Boundary vertices are those that lie on the exterior surface of the mesh. For 3D meshes, these are vertices on surface triangles. For 2D/surface meshes, these are vertices on boundary edges.</p> <p>Parameters:</p> <ul> <li> <code>mesh</code>               (<code>MmgMesh2D | MmgMesh3D | MmgMeshS</code>)           \u2013            <p>MmgMesh2D, MmgMesh3D, or MmgMeshS mesh object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[bool_]</code>           \u2013            <p>Boolean array of length n_vertices, True for boundary vertices.</p> </li> </ul>"},{"location":"api/lagrangian/#mesh-method","title":"Mesh Method","text":"<p>Meshes have a <code>remesh_lagrangian()</code> method for direct use:</p> <pre><code>import mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMesh3D(\"input.mesh\")\n\n# Define displacement field (3D vector at each vertex)\nn_vertices = mesh.get_mesh_size()[\"vertices\"]\ndisplacement = np.zeros((n_vertices, 3))\ndisplacement[:, 0] = 0.1  # Move all vertices 0.1 in x\n\n# Remesh with displacement\nresult = mesh.remesh_lagrangian(displacement)\n</code></pre>"},{"location":"api/lagrangian/#usage-examples","title":"Usage Examples","text":""},{"location":"api/lagrangian/#basic-lagrangian-remeshing","title":"Basic Lagrangian Remeshing","text":"<pre><code>import mmgpy\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\nvertices = mesh.get_vertices()\nn_vertices = len(vertices)\n\n# Create displacement: radial expansion\ncenter = vertices.mean(axis=0)\ndirections = vertices - center\ndistances = np.linalg.norm(directions, axis=1, keepdims=True)\ndirections = directions / (distances + 1e-10)\n\n# 10% radial expansion\ndisplacement = directions * 0.1 * distances\n\n# Apply and remesh\nresult = mesh.remesh_lagrangian(displacement)\n\nprint(f\"Quality: {result.quality_mean_after:.3f}\")\n</code></pre>"},{"location":"api/lagrangian/#boundary-only-displacement","title":"Boundary-Only Displacement","text":"<p>Move only boundary vertices:</p> <pre><code>from mmgpy import detect_boundary_vertices\n\nmesh = mmgpy.read(\"input.mesh\")\nvertices = mesh.get_vertices()\n\n# Find boundary vertices\nboundary_mask = detect_boundary_vertices(mesh)\n\n# Create displacement (only boundary moves)\ndisplacement = np.zeros((len(vertices), 3))\ndisplacement[boundary_mask, 2] = 0.05  # Move boundary up in z\n\n# Remesh\nresult = mesh.remesh_lagrangian(displacement)\n</code></pre>"},{"location":"api/lagrangian/#propagate-displacement-to-interior","title":"Propagate Displacement to Interior","text":"<p>Start with boundary displacement and propagate to interior:</p> <pre><code>from mmgpy import detect_boundary_vertices, propagate_displacement\n\nmesh = mmgpy.read(\"input.mesh\")\nvertices = mesh.get_vertices()\n\n# Boundary displacement\nboundary_mask = detect_boundary_vertices(mesh)\nboundary_disp = np.zeros((len(vertices), 3))\nboundary_disp[boundary_mask, 0] = 0.1\n\n# Propagate to interior (smooth interpolation)\nfull_disp = propagate_displacement(mesh, boundary_disp, boundary_mask)\n\n# Remesh\nresult = mesh.remesh_lagrangian(full_disp)\n</code></pre>"},{"location":"api/lagrangian/#move-mesh-without-remeshing","title":"Move Mesh Without Remeshing","text":"<p>Apply displacement without topology changes:</p> <pre><code>from mmgpy import move_mesh\n\nmesh = mmgpy.read(\"input.mesh\")\nvertices = mesh.get_vertices()\n\n# Displacement\ndisplacement = np.zeros_like(vertices)\ndisplacement[:, 1] = 0.05  # Translate in y\n\n# Apply displacement (modifies mesh in-place)\nmove_mesh(mesh, displacement)\n\n# Now mesh vertices are moved\nnew_vertices = mesh.get_vertices()\n</code></pre>"},{"location":"api/lagrangian/#iterative-motion","title":"Iterative Motion","text":"<p>For large deformations, use multiple small steps:</p> <pre><code>import mmgpy\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Total displacement\ntotal_disp = compute_total_displacement(mesh)\n\n# Apply in 10 steps\nn_steps = 10\nfor i in range(n_steps):\n    step_disp = total_disp / n_steps\n    result = mesh.remesh_lagrangian(step_disp, verbose=-1)\n    print(f\"Step {i+1}: quality={result.quality_mean_after:.3f}\")\n\nmesh.save(\"final.mesh\")\n</code></pre>"},{"location":"api/lagrangian/#with-quality-control","title":"With Quality Control","text":"<p>Combine with remeshing parameters:</p> <pre><code>result = mesh.remesh_lagrangian(\n    displacement,\n    hmin=0.01,\n    hmax=0.1,\n    hausd=0.001,\n    verbose=1,\n)\n</code></pre>"},{"location":"api/lagrangian/#complete-example","title":"Complete Example","text":"<p>Deform a sphere into an ellipsoid:</p> <pre><code>import mmgpy\nimport numpy as np\n\n# Load sphere mesh\nmesh = mmgpy.MmgMesh3D(\"sphere.mesh\")\nvertices = mesh.get_vertices()\n\n# Compute displacement: stretch in z, compress in x and y\ncenter = vertices.mean(axis=0)\nrelative = vertices - center\n\n# Scale factors\nscale = np.array([0.7, 0.7, 1.5])  # Compress x,y, stretch z\n\n# Displacement to achieve scaling\nnew_positions = center + relative * scale\ndisplacement = new_positions - vertices\n\n# Apply with Lagrangian remeshing\nresult = mesh.remesh_lagrangian(\n    displacement,\n    hmax=0.1,\n    verbose=1,\n)\n\nprint(f\"Remeshed ellipsoid:\")\nprint(f\"  Vertices: {result.vertices_before} -&gt; {result.vertices_after}\")\nprint(f\"  Quality: {result.quality_mean_before:.3f} -&gt; {result.quality_mean_after:.3f}\")\n\n# Save result\nmesh.save(\"ellipsoid.vtk\")\n</code></pre>"},{"location":"api/lagrangian/#tips","title":"Tips","text":"<ol> <li>Small steps: For large deformations, use multiple small steps</li> <li>Quality monitoring: Check quality after each step</li> <li>Boundary handling: Use <code>propagate_displacement</code> for interior smoothness</li> <li>Remesh parameters: Combine with <code>hmax</code>, <code>hausd</code> for size control</li> <li>Validation: Validate mesh after each Lagrangian step</li> </ol>"},{"location":"api/mesh-classes/","title":"Mesh Classes","text":"<p>This page documents the mesh classes provided by mmgpy.</p>"},{"location":"api/mesh-classes/#unified-mesh-class","title":"Unified Mesh Class","text":"<p>The <code>Mesh</code> class provides a unified interface that auto-detects mesh type:</p> <p>options: members: - init - kind - save - get_vertices - get_triangles - get_tetrahedra - get_edges - get_mesh_size - remesh - remesh_optimize - remesh_uniform - remesh_levelset - remesh_lagrangian - validate - to_pyvista - set_size_sphere - set_size_box - set_size_cylinder - set_size_from_point - clear_local_sizing - get_local_sizing_count</p> <p>options: show_root_heading: true</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh","title":"mmgpy.Mesh","text":"<pre><code>Mesh(\n    source: NDArray[floating] | str | Path | UnstructuredGrid | PolyData,\n    cells: NDArray[integer] | None = None,\n)\n</code></pre> <p>Unified mesh class with auto-detection of mesh type.</p> <p>This class provides a single interface for working with 2D planar, 3D volumetric, and 3D surface meshes. The mesh type is automatically detected from the input data.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh--parameters","title":"Parameters","text":"<p>source : ndarray | str | Path | pv.UnstructuredGrid | pv.PolyData     Either:     - Vertex coordinates array (requires <code>cells</code> parameter)     - File path to load mesh from     - PyVista mesh object cells : ndarray, optional     Cell connectivity array. Required when <code>source</code> is vertices.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh--attributes","title":"Attributes","text":"<p>kind : MeshKind     The type of mesh (TETRAHEDRAL, TRIANGULAR_2D, or TRIANGULAR_SURFACE).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh--examples","title":"Examples","text":"<p>Create a mesh from vertices and cells:</p> <p>vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]) cells = np.array([[0, 1, 2, 3]]) mesh = Mesh(vertices, cells) mesh.kind MeshKind.TETRAHEDRAL</p> <p>Load a mesh from file:</p> <p>mesh = Mesh(\"mesh.vtk\")</p> <p>Create from PyVista:</p> <p>pv_mesh = pv.read(\"mesh.vtk\") mesh = Mesh(pv_mesh)</p> <p>Initialize a Mesh from various sources.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.kind","title":"kind  <code>property</code>","text":"<pre><code>kind: MeshKind\n</code></pre> <p>Get the mesh kind.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.kind--returns","title":"Returns","text":"<p>MeshKind     The type of mesh.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertices","title":"get_vertices","text":"<pre><code>get_vertices() -&gt; NDArray[np.float64]\n</code></pre> <p>Get vertex coordinates.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertices--returns","title":"Returns","text":"<p>ndarray     Vertex coordinates (Nx2 for 2D, Nx3 for 3D).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertices_with_refs","title":"get_vertices_with_refs","text":"<pre><code>get_vertices_with_refs() -&gt; tuple[NDArray[np.float64], NDArray[np.int64]]\n</code></pre> <p>Get vertex coordinates and reference markers.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertices_with_refs--returns","title":"Returns","text":"<p>vertices : ndarray     Vertex coordinates. refs : ndarray     Reference markers for each vertex.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_vertices","title":"set_vertices","text":"<pre><code>set_vertices(vertices: NDArray[float64], refs: NDArray[int64] | None = None) -&gt; None\n</code></pre> <p>Set vertex coordinates.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_vertices--parameters","title":"Parameters","text":"<p>vertices : ndarray     Vertex coordinates. refs : ndarray, optional     Reference markers for each vertex.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_triangles","title":"get_triangles","text":"<pre><code>get_triangles() -&gt; NDArray[np.int32]\n</code></pre> <p>Get triangle connectivity.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_triangles--returns","title":"Returns","text":"<p>ndarray     Triangle connectivity (Nx3).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_triangles_with_refs","title":"get_triangles_with_refs","text":"<pre><code>get_triangles_with_refs() -&gt; tuple[NDArray[np.int32], NDArray[np.int64]]\n</code></pre> <p>Get triangle connectivity and reference markers.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_triangles_with_refs--returns","title":"Returns","text":"<p>triangles : ndarray     Triangle connectivity. refs : ndarray     Reference markers for each triangle.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_triangles","title":"set_triangles","text":"<pre><code>set_triangles(triangles: NDArray[int32], refs: NDArray[int64] | None = None) -&gt; None\n</code></pre> <p>Set triangle connectivity.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_triangles--parameters","title":"Parameters","text":"<p>triangles : ndarray     Triangle connectivity (Nx3). refs : ndarray, optional     Reference markers for each triangle.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; NDArray[np.int32]\n</code></pre> <p>Get edge connectivity.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_edges--returns","title":"Returns","text":"<p>ndarray     Edge connectivity (Nx2).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_edges_with_refs","title":"get_edges_with_refs","text":"<pre><code>get_edges_with_refs() -&gt; tuple[NDArray[np.int32], NDArray[np.int64]]\n</code></pre> <p>Get edge connectivity and reference markers.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_edges_with_refs--returns","title":"Returns","text":"<p>edges : ndarray     Edge connectivity. refs : ndarray     Reference markers for each edge.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_edges","title":"set_edges","text":"<pre><code>set_edges(edges: NDArray[int32], refs: NDArray[int64] | None = None) -&gt; None\n</code></pre> <p>Set edge connectivity.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_edges--parameters","title":"Parameters","text":"<p>edges : ndarray     Edge connectivity (Nx2). refs : ndarray, optional     Reference markers for each edge.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_tetrahedra","title":"get_tetrahedra","text":"<pre><code>get_tetrahedra() -&gt; NDArray[np.int32]\n</code></pre> <p>Get tetrahedra connectivity.</p> <p>Only available for TETRAHEDRAL meshes.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_tetrahedra--returns","title":"Returns","text":"<p>ndarray     Tetrahedra connectivity (Nx4).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_tetrahedra--raises","title":"Raises","text":"<p>TypeError     If mesh is not TETRAHEDRAL.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_tetrahedra_with_refs","title":"get_tetrahedra_with_refs","text":"<pre><code>get_tetrahedra_with_refs() -&gt; tuple[NDArray[np.int32], NDArray[np.int64]]\n</code></pre> <p>Get tetrahedra connectivity and reference markers.</p> <p>Only available for TETRAHEDRAL meshes.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_tetrahedra_with_refs--returns","title":"Returns","text":"<p>tetrahedra : ndarray     Tetrahedra connectivity. refs : ndarray     Reference markers for each tetrahedron.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_tetrahedra_with_refs--raises","title":"Raises","text":"<p>TypeError     If mesh is not TETRAHEDRAL.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_elements","title":"get_elements","text":"<pre><code>get_elements() -&gt; NDArray[np.int32]\n</code></pre> <p>Get primary element connectivity (alias for get_tetrahedra).</p> <p>Only available for TETRAHEDRAL meshes.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_elements--returns","title":"Returns","text":"<p>ndarray     Element connectivity (Nx4 tetrahedra).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_elements--raises","title":"Raises","text":"<p>TypeError     If mesh is not TETRAHEDRAL.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_elements_with_refs","title":"get_elements_with_refs","text":"<pre><code>get_elements_with_refs() -&gt; tuple[NDArray[np.int32], NDArray[np.int64]]\n</code></pre> <p>Get primary element connectivity and reference markers.</p> <p>Only available for TETRAHEDRAL meshes.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_elements_with_refs--returns","title":"Returns","text":"<p>elements : ndarray     Element connectivity. refs : ndarray     Reference markers for each element.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_elements_with_refs--raises","title":"Raises","text":"<p>TypeError     If mesh is not TETRAHEDRAL.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_field","title":"set_field","text":"<pre><code>set_field(key: str, value: NDArray[float64]) -&gt; None\n</code></pre> <p>Set a solution field.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.set_field--parameters","title":"Parameters","text":"<p>key : str     Field name. value : ndarray     Field values (one per vertex).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_field","title":"get_field","text":"<pre><code>get_field(key: str) -&gt; NDArray[np.float64]\n</code></pre> <p>Get a solution field.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_field--parameters","title":"Parameters","text":"<p>key : str     Field name.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_field--returns","title":"Returns","text":"<p>ndarray     Field values.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: str, value: NDArray[float64]) -&gt; None\n</code></pre> <p>Set a solution field using dictionary syntax.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; NDArray[np.float64]\n</code></pre> <p>Get a solution field using dictionary syntax.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_adjacent_elements","title":"get_adjacent_elements","text":"<pre><code>get_adjacent_elements(idx: int) -&gt; NDArray[np.int32]\n</code></pre> <p>Get indices of elements adjacent to a given element.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_adjacent_elements--parameters","title":"Parameters","text":"<p>idx : int     Element index (1-based for MMG).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_adjacent_elements--returns","title":"Returns","text":"<p>ndarray     Indices of adjacent elements.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertex_neighbors","title":"get_vertex_neighbors","text":"<pre><code>get_vertex_neighbors(idx: int) -&gt; NDArray[np.int32]\n</code></pre> <p>Get indices of vertices connected to a given vertex.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertex_neighbors--parameters","title":"Parameters","text":"<p>idx : int     Vertex index (1-based for MMG).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_vertex_neighbors--returns","title":"Returns","text":"<p>ndarray     Indices of neighboring vertices.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_element_quality","title":"get_element_quality","text":"<pre><code>get_element_quality(idx: int) -&gt; float\n</code></pre> <p>Get quality metric for a single element.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_element_quality--parameters","title":"Parameters","text":"<p>idx : int     Element index (1-based for MMG).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_element_quality--returns","title":"Returns","text":"<p>float     Quality metric (0-1, higher is better).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_element_qualities","title":"get_element_qualities","text":"<pre><code>get_element_qualities() -&gt; NDArray[np.float64]\n</code></pre> <p>Get quality metrics for all elements.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.get_element_qualities--returns","title":"Returns","text":"<p>ndarray     Quality metrics for all elements.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.save","title":"save","text":"<pre><code>save(filename: str | Path) -&gt; None\n</code></pre> <p>Save mesh to file.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.save--parameters","title":"Parameters","text":"<p>filename : str or Path     Output file path. Format determined by extension.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh","title":"remesh","text":"<pre><code>remesh(\n    options: Mmg3DOptions | Mmg2DOptions | MmgSOptions | None = None, **kwargs: Any\n) -&gt; RemeshResult\n</code></pre> <p>Remesh the mesh in-place.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh--parameters","title":"Parameters","text":"<p>options : Mmg3DOptions | Mmg2DOptions | MmgSOptions, optional     Options object for remeshing parameters. **kwargs : float     Individual remeshing parameters (hmin, hmax, hsiz, hausd, etc.).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh--returns","title":"Returns","text":"<p>RemeshResult     Statistics from the remeshing operation.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_lagrangian","title":"remesh_lagrangian","text":"<pre><code>remesh_lagrangian(displacement: NDArray[float64], **kwargs: Any) -&gt; RemeshResult\n</code></pre> <p>Remesh with Lagrangian motion.</p> <p>Only available for TETRAHEDRAL and TRIANGULAR_2D meshes.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_lagrangian--parameters","title":"Parameters","text":"<p>displacement : ndarray     Displacement field for each vertex. **kwargs : float     Additional remeshing parameters.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_lagrangian--returns","title":"Returns","text":"<p>RemeshResult     Statistics from the remeshing operation.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_lagrangian--raises","title":"Raises","text":"<p>TypeError     If mesh is TRIANGULAR_SURFACE.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_levelset","title":"remesh_levelset","text":"<pre><code>remesh_levelset(levelset: NDArray[float64], **kwargs: Any) -&gt; RemeshResult\n</code></pre> <p>Remesh with level-set discretization.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_levelset--parameters","title":"Parameters","text":"<p>levelset : ndarray     Level-set field for each vertex. **kwargs : float     Additional remeshing parameters.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.remesh_levelset--returns","title":"Returns","text":"<p>RemeshResult     Statistics from the remeshing operation.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.to_pyvista","title":"to_pyvista","text":"<pre><code>to_pyvista(*, include_refs: bool = True) -&gt; pv.UnstructuredGrid | pv.PolyData\n</code></pre> <p>Convert to PyVista mesh.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.to_pyvista--parameters","title":"Parameters","text":"<p>include_refs : bool     Include reference markers as cell data.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.to_pyvista--returns","title":"Returns","text":"<p>pv.UnstructuredGrid | pv.PolyData     PyVista mesh object.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.validate","title":"validate","text":"<pre><code>validate(\n    *,\n    detailed: bool = False,\n    strict: bool = False,\n    check_geometry: bool = True,\n    check_topology: bool = True,\n    check_quality: bool = True,\n    min_quality: float = 0.1,\n) -&gt; bool | ValidationReport\n</code></pre> <p>Validate the mesh and check for issues.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.validate--parameters","title":"Parameters","text":"<p>detailed : bool     If True, return a ValidationReport with detailed information.     If False, return a simple boolean. strict : bool     If True, raise ValidationError on any issue (including warnings). check_geometry : bool     Check for geometric issues (inverted/degenerate elements). check_topology : bool     Check for topological issues (orphan vertices, non-manifold edges). check_quality : bool     Check element quality against threshold. min_quality : float     Minimum acceptable element quality (0-1).</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.validate--returns","title":"Returns","text":"<p>bool | ValidationReport     If detailed=False, returns True if valid, False otherwise.     If detailed=True, returns full ValidationReport.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.validate--raises","title":"Raises","text":"<p>ValidationError     If strict=True and any issues are found.</p>"},{"location":"api/mesh-classes/#mmgpy.Mesh.validate--examples","title":"Examples","text":"<p>mesh = Mesh(vertices, cells) if mesh.validate(): ...     print(\"Mesh is valid\")</p> <p>report = mesh.validate(detailed=True) print(f\"Quality: {report.quality.mean:.3f}\")</p>"},{"location":"api/mesh-classes/#mmgpy.MeshKind","title":"mmgpy.MeshKind","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of mesh types.</p>"},{"location":"api/mesh-classes/#mmgpy.MeshKind--attributes","title":"Attributes","text":"<p>TETRAHEDRAL     3D volumetric mesh with tetrahedral elements. TRIANGULAR_2D     2D planar mesh with triangular elements. TRIANGULAR_SURFACE     3D surface mesh with triangular elements.</p>"},{"location":"api/mesh-classes/#3d-volume-mesh","title":"3D Volume Mesh","text":"<p>options: members: - init - from_pyvista - save - get_mesh_size - get_vertices - set_vertices - get_tetrahedra - set_tetrahedra - get_triangles - set_triangles - get_edges - set_edges - get_element_quality - get_adjacent_elements - get_vertex_neighbors - remesh - remesh_optimize - remesh_uniform - remesh_lagrangian - remesh_levelset - validate - set_field - get_field - getitem - setitem - to_pyvista - set_size_sphere - set_size_box - set_size_cylinder - set_size_from_point - clear_local_sizing - get_local_sizing_count - apply_local_sizing - set_corners - set_required_vertices - set_ridge_edges</p>"},{"location":"api/mesh-classes/#mmgpy.MmgMesh3D","title":"mmgpy.MmgMesh3D","text":""},{"location":"api/mesh-classes/#2d-planar-mesh","title":"2D Planar Mesh","text":"<p>options: members: - init - from_pyvista - save - get_mesh_size - get_vertices - set_vertices - get_triangles - set_triangles - get_edges - set_edges - get_element_quality - remesh - remesh_optimize - remesh_uniform - remesh_lagrangian - remesh_levelset - validate - set_field - get_field - getitem - setitem - to_pyvista - set_size_sphere - set_size_box - set_size_from_point - clear_local_sizing - get_local_sizing_count - apply_local_sizing</p>"},{"location":"api/mesh-classes/#mmgpy.MmgMesh2D","title":"mmgpy.MmgMesh2D","text":""},{"location":"api/mesh-classes/#3d-surface-mesh","title":"3D Surface Mesh","text":"<p>options: members: - init - from_pyvista - save - get_mesh_size - get_vertices - set_vertices - get_triangles - set_triangles - get_edges - set_edges - get_element_quality - remesh - remesh_optimize - remesh_uniform - remesh_levelset - validate - set_field - get_field - getitem - setitem - to_pyvista - set_size_sphere - set_size_box - set_size_cylinder - set_size_from_point - clear_local_sizing - get_local_sizing_count - apply_local_sizing</p>"},{"location":"api/mesh-classes/#mmgpy.MmgMeshS","title":"mmgpy.MmgMeshS","text":""},{"location":"api/mesh-classes/#usage-examples","title":"Usage Examples","text":""},{"location":"api/mesh-classes/#creating-meshes","title":"Creating Meshes","text":"<pre><code>import mmgpy\nimport numpy as np\n\n# From file\nmesh = mmgpy.MmgMesh3D(\"input.mesh\")\n\n# From arrays\nvertices = np.array([\n    [0, 0, 0],\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n], dtype=np.float64)\n\ntetrahedra = np.array([[0, 1, 2, 3]], dtype=np.int32)\n\nmesh = mmgpy.MmgMesh3D(vertices, tetrahedra)\n</code></pre>"},{"location":"api/mesh-classes/#accessing-mesh-data","title":"Accessing Mesh Data","text":"<pre><code># Get mesh statistics\nsize = mesh.get_mesh_size()\nprint(f\"Vertices: {size['vertices']}\")\nprint(f\"Tetrahedra: {size['tetrahedra']}\")\nprint(f\"Triangles: {size['triangles']}\")\n\n# Get arrays\nvertices = mesh.get_vertices()      # Shape: (n_vertices, 3)\ntetrahedra = mesh.get_tetrahedra()  # Shape: (n_tetrahedra, 4)\ntriangles = mesh.get_triangles()    # Shape: (n_triangles, 3)\n</code></pre>"},{"location":"api/mesh-classes/#working-with-fields","title":"Working with Fields","text":"<pre><code>import numpy as np\n\n# Set a scalar field\ntemperatures = np.random.rand(mesh.get_mesh_size()['vertices'])\nmesh[\"temperature\"] = temperatures\n\n# Get a field\ntemps = mesh[\"temperature\"]\n\n# Set using method\nmesh.set_field(\"velocity\", velocity_vectors)\n\n# Get using method\nvel = mesh.get_field(\"velocity\")\n</code></pre>"},{"location":"api/mesh-classes/#remeshing","title":"Remeshing","text":"<pre><code>from mmgpy import Mmg3DOptions\n\n# With options object\nopts = Mmg3DOptions(hmax=0.1, hausd=0.001)\nresult = mesh.remesh(opts)\n\n# With keyword arguments\nresult = mesh.remesh(hmax=0.1, hausd=0.001)\n\n# Convenience methods\nresult = mesh.remesh_optimize()        # Quality only\nresult = mesh.remesh_uniform(size=0.1) # Uniform size\n</code></pre>"},{"location":"api/metrics/","title":"Metrics","text":"<p>This page documents the metric tensor operations in the <code>mmgpy.metrics</code> module.</p>"},{"location":"api/metrics/#overview","title":"Overview","text":"<p>Metric tensors control anisotropic mesh adaptation. A metric at each vertex specifies:</p> <ul> <li>Isotropic: Target edge length (single scalar)</li> <li>Anisotropic: Target lengths along different directions (tensor)</li> </ul>"},{"location":"api/metrics/#metric-creation","title":"Metric Creation","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/metrics/#mmgpy.metrics.create_isotropic_metric","title":"mmgpy.metrics.create_isotropic_metric","text":"<pre><code>create_isotropic_metric(\n    h: float | NDArray[float64], n_vertices: int | None = None, dim: int = 3\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Create an isotropic metric field from scalar sizing values.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_isotropic_metric--parameters","title":"Parameters","text":"<p>h : float or array_like     Desired element size(s). If scalar, same size at all vertices.     If array, must have shape (n_vertices,) or (n_vertices, 1). n_vertices : int, optional     Number of vertices. Required if h is a scalar. dim : int, optional     Mesh dimension (2 or 3). Default is 3.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_isotropic_metric--returns","title":"Returns","text":"<p>NDArray[np.float64]     Metric tensor array with shape (n_vertices, n_components) where     n_components is 6 for 3D and 3 for 2D.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_isotropic_metric--examples","title":"Examples","text":"<p>metric = create_isotropic_metric(0.1, n_vertices=100, dim=3) metric.shape (100, 6)</p> <p>sizes = np.linspace(0.1, 0.5, 100) metric = create_isotropic_metric(sizes, dim=3) metric.shape (100, 6)</p>"},{"location":"api/metrics/#mmgpy.metrics.create_anisotropic_metric","title":"mmgpy.metrics.create_anisotropic_metric","text":"<pre><code>create_anisotropic_metric(\n    sizes: NDArray[float64], directions: NDArray[float64] | None = None\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Create an anisotropic metric tensor from principal sizes and directions.</p> <p>The metric tensor M is constructed as: M = R @ D @ R.T where D is diagonal with D[i,i] = 1/sizes[i]^2 and R contains the principal direction vectors as columns.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_anisotropic_metric--parameters","title":"Parameters","text":"<p>sizes : array_like     Principal element sizes. Shape (3,) for 3D, (2,) for 2D.     Can also be (n_vertices, 3) or (n_vertices, 2) for per-vertex sizes. directions : array_like, optional     Principal direction vectors. Shape (3, 3) or (2, 2) for single metric,     or (n_vertices, 3, 3) or (n_vertices, 2, 2) for per-vertex directions.     Columns are eigenvectors. If None, uses identity (coordinate-aligned).</p>"},{"location":"api/metrics/#mmgpy.metrics.create_anisotropic_metric--returns","title":"Returns","text":"<p>NDArray[np.float64]     Metric tensor(s). Shape (6,) for single 3D metric, (3,) for single 2D,     or (n_vertices, 6) / (n_vertices, 3) for per-vertex metrics.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_anisotropic_metric--examples","title":"Examples","text":"<p>Create a metric with 10x stretch in x-direction:</p> <p>sizes = np.array([0.1, 1.0, 1.0])  # Small in x, large in y,z metric = create_anisotropic_metric(sizes) metric array([100.,   0.,   0.,   1.,   0.,   1.])</p> <p>Create a rotated metric:</p> <p>import numpy as np theta = np.pi / 4  # 45 degrees R = np.array([[np.cos(theta), -np.sin(theta), 0], ...               [np.sin(theta),  np.cos(theta), 0], ...               [0,              0,             1]]) sizes = np.array([0.1, 1.0, 1.0]) metric = create_anisotropic_metric(sizes, R)</p>"},{"location":"api/metrics/#mmgpy.metrics.create_metric_from_hessian","title":"mmgpy.metrics.create_metric_from_hessian","text":"<pre><code>create_metric_from_hessian(\n    hessian: NDArray[float64],\n    target_error: float = 0.001,\n    hmin: float | None = None,\n    hmax: float | None = None,\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Create metric tensor from Hessian matrix for interpolation error control.</p> <p>Given a Hessian H of a solution field, constructs a metric M such that the interpolation error is bounded by target_error. This is used for solution-adaptive mesh refinement.</p> <p>The metric eigenvalues are: lambda_i = c * |hessian_eigenvalue_i| / target_error where c is a constant depending on the interpolation order.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_metric_from_hessian--parameters","title":"Parameters","text":"<p>hessian : array_like     Hessian tensor(s). Shape (6,) or (n, 6) for 3D, (3,) or (n, 3) for 2D.     Components: [H11, H12, H13, H22, H23, H33] for 3D. target_error : float, optional     Target interpolation error. Default is 1e-3. hmin : float, optional     Minimum element size. Limits maximum metric eigenvalues. hmax : float, optional     Maximum element size. Limits minimum metric eigenvalues.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_metric_from_hessian--returns","title":"Returns","text":"<p>NDArray[np.float64]     Metric tensor(s) for adaptive remeshing.</p>"},{"location":"api/metrics/#mmgpy.metrics.create_metric_from_hessian--notes","title":"Notes","text":"<p>For P1 interpolation, the interpolation error is bounded by:     e &lt;= (1/8) * h^2 * |d\u00b2u/ds\u00b2|_max</p> <p>This function computes the metric that achieves a specified error bound.</p>"},{"location":"api/metrics/#metric-operations","title":"Metric Operations","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/metrics/#mmgpy.metrics.intersect_metrics","title":"mmgpy.metrics.intersect_metrics","text":"<pre><code>intersect_metrics(\n    m1: NDArray[float64], m2: NDArray[float64], dim: int | None = None\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Compute the intersection of two metric tensors.</p> <p>The intersection produces a metric that is at least as refined as both input metrics in all directions. This is useful for combining metrics from different sources (e.g., boundary layer + feature-based).</p> <p>The intersection is computed via simultaneous diagonalization: M_intersect = M1^(1/2) @ N @ M1^(1/2) where N is diagonal with max eigenvalues of M1^(-1/2) @ M2 @ M1^(-1/2).</p>"},{"location":"api/metrics/#mmgpy.metrics.intersect_metrics--parameters","title":"Parameters","text":"<p>m1, m2 : array_like     Metric tensors to intersect. Must have same shape.     Shape (6,) or (n, 6) for 3D, (3,) or (n, 3) for 2D. dim : int, optional     Dimension (2 or 3). Inferred from tensor shape if not provided.</p>"},{"location":"api/metrics/#mmgpy.metrics.intersect_metrics--returns","title":"Returns","text":"<p>NDArray[np.float64]     Intersected metric tensor(s), same shape as inputs.</p>"},{"location":"api/metrics/#mmgpy.metrics.compute_metric_eigenpairs","title":"mmgpy.metrics.compute_metric_eigenpairs","text":"<pre><code>compute_metric_eigenpairs(\n    tensor: NDArray[float64], dim: int | None = None\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]\n</code></pre> <p>Extract principal sizes and directions from metric tensor(s).</p>"},{"location":"api/metrics/#mmgpy.metrics.compute_metric_eigenpairs--parameters","title":"Parameters","text":"<p>tensor : array_like     Metric tensor(s). Shape (6,) or (n, 6) for 3D, (3,) or (n, 3) for 2D. dim : int, optional     Dimension (2 or 3). Inferred from tensor shape if not provided.</p>"},{"location":"api/metrics/#mmgpy.metrics.compute_metric_eigenpairs--returns","title":"Returns","text":"<p>tuple[NDArray, NDArray]     (sizes, directions) where:     - sizes: Principal element sizes, shape (3,) or (n, 3) for 3D     - directions: Eigenvector matrices, shape (3, 3) or (n, 3, 3) for 3D       Columns are eigenvectors corresponding to sizes.</p>"},{"location":"api/metrics/#mmgpy.metrics.compute_metric_eigenpairs--examples","title":"Examples","text":"<p>tensor = np.array([100., 0., 0., 1., 0., 1.])  # 10x stretch in x sizes, directions = compute_metric_eigenpairs(tensor) sizes array([0.1, 1. , 1. ])</p>"},{"location":"api/metrics/#tensor-utilities","title":"Tensor Utilities","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/metrics/#mmgpy.metrics.tensor_to_matrix","title":"mmgpy.metrics.tensor_to_matrix","text":"<pre><code>tensor_to_matrix(\n    tensor: NDArray[float64], dim: int | None = None\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Convert tensor storage format to full symmetric matrix.</p>"},{"location":"api/metrics/#mmgpy.metrics.tensor_to_matrix--parameters","title":"Parameters","text":"<p>tensor : array_like     Tensor in storage format. Shape (6,) or (n, 6) for 3D,     (3,) or (n, 3) for 2D. dim : int, optional     Dimension (2 or 3). Inferred from tensor shape if not provided.</p>"},{"location":"api/metrics/#mmgpy.metrics.tensor_to_matrix--returns","title":"Returns","text":"<p>NDArray[np.float64]     Full symmetric matrix. Shape (3, 3) or (n, 3, 3) for 3D,     (2, 2) or (n, 2, 2) for 2D.</p>"},{"location":"api/metrics/#mmgpy.metrics.matrix_to_tensor","title":"mmgpy.metrics.matrix_to_tensor","text":"<pre><code>matrix_to_tensor(M: NDArray[float64]) -&gt; NDArray[np.float64]\n</code></pre> <p>Convert full symmetric matrix to tensor storage format.</p>"},{"location":"api/metrics/#mmgpy.metrics.matrix_to_tensor--parameters","title":"Parameters","text":"<p>M : array_like     Full symmetric matrix. Shape (3, 3) or (n, 3, 3) for 3D,     (2, 2) or (n, 2, 2) for 2D.</p>"},{"location":"api/metrics/#mmgpy.metrics.matrix_to_tensor--returns","title":"Returns","text":"<p>NDArray[np.float64]     Tensor in storage format. Shape (6,) or (n, 6) for 3D,     (3,) or (n, 3) for 2D.</p>"},{"location":"api/metrics/#mmgpy.metrics.validate_metric_tensor","title":"mmgpy.metrics.validate_metric_tensor","text":"<pre><code>validate_metric_tensor(\n    tensor: NDArray[float64], dim: int | None = None, *, raise_on_invalid: bool = True\n) -&gt; tuple[bool, str]\n</code></pre> <p>Validate that metric tensor(s) are positive-definite.</p> <p>A valid metric tensor must be symmetric positive-definite, meaning all eigenvalues must be strictly positive.</p>"},{"location":"api/metrics/#mmgpy.metrics.validate_metric_tensor--parameters","title":"Parameters","text":"<p>tensor : array_like     Tensor(s) to validate. Shape (6,) or (n, 6) for 3D,     (3,) or (n, 3) for 2D. dim : int, optional     Dimension (2 or 3). Inferred from tensor shape if not provided. raise_on_invalid : bool, optional     If True, raises ValueError on invalid tensors. Default is True.</p>"},{"location":"api/metrics/#mmgpy.metrics.validate_metric_tensor--returns","title":"Returns","text":"<p>tuple[bool, str]     (is_valid, message) tuple.</p>"},{"location":"api/metrics/#mmgpy.metrics.validate_metric_tensor--raises","title":"Raises","text":"<p>ValueError     If raise_on_invalid is True and tensor is not valid.</p>"},{"location":"api/metrics/#mmgpy.metrics.validate_metric_tensor--examples","title":"Examples","text":"<p>valid_tensor = np.array([1.0, 0.0, 0.0, 1.0, 0.0, 1.0]) validate_metric_tensor(valid_tensor) (True, 'Valid positive-definite metric tensor')</p> <p>invalid_tensor = np.array([-1.0, 0.0, 0.0, 1.0, 0.0, 1.0]) validate_metric_tensor(invalid_tensor, raise_on_invalid=False) (False, 'Tensor has non-positive eigenvalues...')</p>"},{"location":"api/metrics/#usage-examples","title":"Usage Examples","text":""},{"location":"api/metrics/#isotropic-metric","title":"Isotropic Metric","text":"<p>Create a metric for uniform element sizes:</p> <pre><code>import mmgpy\nimport mmgpy.metrics as metrics\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\nn_vertices = mesh.get_mesh_size()[\"vertices\"]\n\n# Uniform size everywhere\nsizes = np.ones(n_vertices) * 0.1\nmetric = metrics.create_isotropic_metric(sizes)\n\n# Apply to mesh\nmesh[\"metric\"] = metric\n\n# Remesh using the metric\nresult = mesh.remesh()\n</code></pre>"},{"location":"api/metrics/#variable-size-metric","title":"Variable Size Metric","text":"<p>Size varying with position:</p> <pre><code>import numpy as np\n\nvertices = mesh.get_vertices()\n\n# Size increases with distance from origin\ndistances = np.linalg.norm(vertices, axis=1)\nsizes = 0.01 + 0.1 * distances\n\nmetric = metrics.create_isotropic_metric(sizes)\nmesh[\"metric\"] = metric\n</code></pre>"},{"location":"api/metrics/#anisotropic-metric","title":"Anisotropic Metric","text":"<p>Different sizes in different directions:</p> <pre><code>import numpy as np\n\nn_vertices = mesh.get_mesh_size()[\"vertices\"]\n\n# Define principal directions and sizes at each vertex\n# directions: (n_vertices, 3, 3) - orthonormal basis at each vertex\n# sizes: (n_vertices, 3) - sizes along each principal direction\n\n# Example: stretch along z-axis\ndirections = np.tile(np.eye(3), (n_vertices, 1, 1))  # Identity basis\nsizes = np.tile([0.1, 0.1, 0.05], (n_vertices, 1))   # Smaller in z\n\nmetric = metrics.create_anisotropic_metric(directions, sizes)\nmesh[\"metric\"] = metric\n</code></pre>"},{"location":"api/metrics/#metric-from-hessian","title":"Metric from Hessian","text":"<p>Adapt mesh to solution curvature:</p> <pre><code># Solution field (e.g., temperature)\nsolution = np.sin(vertices[:, 0] * 2 * np.pi)\n\n# Compute Hessian (second derivatives) - requires additional computation\n# hessian shape: (n_vertices, 6) for symmetric 3x3 tensor\nhessian = compute_hessian(solution, mesh)  # Implementation needed\n\n# Create metric from Hessian\nmetric = metrics.create_metric_from_hessian(\n    hessian,\n    epsilon=0.01,  # Target interpolation error\n)\n\nmesh[\"metric\"] = metric\n</code></pre>"},{"location":"api/metrics/#metric-intersection","title":"Metric Intersection","text":"<p>Combine multiple metrics (minimum size wins):</p> <pre><code># Two different metrics\nmetric1 = metrics.create_isotropic_metric(sizes1)\nmetric2 = metrics.create_isotropic_metric(sizes2)\n\n# Intersect: take minimum size in all directions\ncombined = metrics.intersect_metrics(metric1, metric2)\nmesh[\"metric\"] = combined\n</code></pre>"},{"location":"api/metrics/#extracting-metric-information","title":"Extracting Metric Information","text":"<pre><code># Get current metric\nmetric = mesh[\"metric\"]\n\n# Extract eigenvalues and eigenvectors\neigenvalues, eigenvectors = metrics.compute_metric_eigenpairs(metric)\n\n# eigenvalues shape: (n_vertices, 3) - 1/size^2 along each direction\n# eigenvectors shape: (n_vertices, 3, 3) - principal directions\n\n# Convert to sizes\nsizes = 1.0 / np.sqrt(eigenvalues)\nprint(f\"Size range: {sizes.min():.4f} to {sizes.max():.4f}\")\n</code></pre>"},{"location":"api/metrics/#tensor-format-conversion","title":"Tensor Format Conversion","text":"<p>MMG uses symmetric tensors in Voigt notation:</p> <pre><code># 3D: 6 components per vertex\n# [M11, M12, M13, M22, M23, M33]\n\n# 2D: 3 components per vertex\n# [M11, M12, M22]\n\n# Convert tensor to full matrix\ntensor = mesh[\"metric\"][0]  # First vertex\nmatrix = metrics.tensor_to_matrix(tensor)\nprint(matrix.shape)  # (3, 3)\n\n# Convert matrix back to tensor\ntensor_back = metrics.matrix_to_tensor(matrix)\n</code></pre>"},{"location":"api/metrics/#validation","title":"Validation","text":"<p>Check metric tensor validity:</p> <pre><code>metric = mesh[\"metric\"]\n\n# Validate: must be symmetric positive definite\nis_valid = metrics.validate_metric_tensor(metric)\nif not is_valid:\n    print(\"Warning: invalid metric tensor\")\n</code></pre>"},{"location":"api/metrics/#metric-formats","title":"Metric Formats","text":""},{"location":"api/metrics/#3d-metrics-mmgmesh3d","title":"3D Metrics (MmgMesh3D)","text":"<p>Symmetric 3x3 tensor stored as 6 components:</p> <pre><code>    [M11  M12  M13]\nM = [M12  M22  M23]  -&gt; [M11, M12, M13, M22, M23, M33]\n    [M13  M23  M33]\n</code></pre> <p>Metric field shape: <code>(n_vertices, 6)</code></p>"},{"location":"api/metrics/#2d-metrics-mmgmesh2d","title":"2D Metrics (MmgMesh2D)","text":"<p>Symmetric 2x2 tensor stored as 3 components:</p> <pre><code>    [M11  M12]\nM = [M12  M22]  -&gt; [M11, M12, M22]\n</code></pre> <p>Metric field shape: <code>(n_vertices, 3)</code></p>"},{"location":"api/metrics/#surface-metrics-mmgmeshs","title":"Surface Metrics (MmgMeshS)","text":"<p>Same as 3D: <code>(n_vertices, 6)</code></p>"},{"location":"api/metrics/#tips","title":"Tips","text":"<ol> <li> <p>Isotropic first: Start with isotropic metrics, add anisotropy only when needed</p> </li> <li> <p>Size bounds: Ensure metric sizes are within reasonable bounds relative to domain size</p> </li> <li> <p>Gradation: MMG's <code>hgrad</code> parameter controls size gradation regardless of metric</p> </li> <li> <p>Validation: Always validate metric tensors before remeshing</p> </li> <li> <p>Combination: Use <code>intersect_metrics</code> to combine sizing from different sources</p> </li> </ol>"},{"location":"api/options/","title":"Options Classes","text":"<p>This page documents the options classes for configuring remeshing operations.</p>"},{"location":"api/options/#overview","title":"Overview","text":"<p>Each mesh type has a corresponding options class:</p> Mesh Type Options Class <code>MmgMesh3D</code> <code>Mmg3DOptions</code> <code>MmgMesh2D</code> <code>Mmg2DOptions</code> <code>MmgMeshS</code> <code>MmgSOptions</code> <p>Options classes are immutable dataclasses with:</p> <ul> <li>Type-checked parameters</li> <li>IDE autocomplete support</li> <li>Factory methods for common configurations</li> <li>Conversion to dictionary for <code>remesh()</code></li> </ul>"},{"location":"api/options/#3d-options","title":"3D Options","text":"<p>options: show_root_heading: true members: - init - fine - coarse - optimize_only - to_dict</p>"},{"location":"api/options/#mmgpy.Mmg3DOptions","title":"mmgpy.Mmg3DOptions  <code>dataclass</code>","text":"<pre><code>Mmg3DOptions(\n    *,\n    hmin: float | None = None,\n    hmax: float | None = None,\n    hsiz: float | None = None,\n    hausd: float | None = None,\n    hgrad: float | None = None,\n    hgradreq: float | None = None,\n    ar: float | None = None,\n    verbose: int | None = None,\n    mem: int | None = None,\n    optim: bool = False,\n    noinsert: bool = False,\n    noswap: bool = False,\n    nomove: bool = False,\n    nosurf: bool = False,\n)\n</code></pre> <p>               Bases: <code>_MmgOptionsBase</code></p> <p>Options for 3D tetrahedral mesh remeshing (MMG3D).</p> <p>All parameters are optional. When None, MMG uses its internal defaults. Options are immutable after creation.</p> Inherits from _MmgOptionsBase <p>hmin, hmax, hsiz, hausd, hgrad, hgradreq, ar, verbose, mem, optim, noinsert, noswap, nomove</p>"},{"location":"api/options/#mmgpy.Mmg3DOptions--additional-attributes","title":"Additional Attributes","text":"<p>nosurf : bool     Disable surface modifications (3D only).</p>"},{"location":"api/options/#mmgpy.Mmg3DOptions--example","title":"Example:","text":"<p>opts = Mmg3DOptions(hmax=0.1, hausd=0.01) mesh.remesh(opts)  # Pass options directly</p>"},{"location":"api/options/#mmgpy.Mmg3DOptions.nosurf","title":"nosurf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nosurf: bool = False\n</code></pre> <p>Disable surface modifications (3D only).</p>"},{"location":"api/options/#mmgpy.Mmg3DOptions.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate options after initialization.</p>"},{"location":"api/options/#2d-options","title":"2D Options","text":"<p>options: show_root_heading: true members: - init - fine - coarse - optimize_only - to_dict</p>"},{"location":"api/options/#mmgpy.Mmg2DOptions","title":"mmgpy.Mmg2DOptions  <code>dataclass</code>","text":"<pre><code>Mmg2DOptions(\n    *,\n    hmin: float | None = None,\n    hmax: float | None = None,\n    hsiz: float | None = None,\n    hausd: float | None = None,\n    hgrad: float | None = None,\n    hgradreq: float | None = None,\n    ar: float | None = None,\n    verbose: int | None = None,\n    mem: int | None = None,\n    optim: bool = False,\n    noinsert: bool = False,\n    noswap: bool = False,\n    nomove: bool = False,\n    nosurf: bool = False,\n)\n</code></pre> <p>               Bases: <code>_MmgOptionsBase</code></p> <p>Options for 2D triangular mesh remeshing (MMG2D).</p> <p>All parameters are optional. When None, MMG uses its internal defaults. Options are immutable after creation.</p> Inherits from _MmgOptionsBase <p>hmin, hmax, hsiz, hausd, hgrad, hgradreq, ar, verbose, mem, optim, noinsert, noswap, nomove</p>"},{"location":"api/options/#mmgpy.Mmg2DOptions--additional-attributes","title":"Additional Attributes","text":"<p>nosurf : bool     Disable boundary modifications.</p>"},{"location":"api/options/#mmgpy.Mmg2DOptions.nosurf","title":"nosurf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nosurf: bool = False\n</code></pre> <p>Disable boundary modifications.</p>"},{"location":"api/options/#mmgpy.Mmg2DOptions.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate options after initialization.</p>"},{"location":"api/options/#surface-options","title":"Surface Options","text":"<p>options: show_root_heading: true members: - init - fine - coarse - optimize_only - to_dict</p>"},{"location":"api/options/#mmgpy.MmgSOptions","title":"mmgpy.MmgSOptions  <code>dataclass</code>","text":"<pre><code>MmgSOptions(\n    *,\n    hmin: float | None = None,\n    hmax: float | None = None,\n    hsiz: float | None = None,\n    hausd: float | None = None,\n    hgrad: float | None = None,\n    hgradreq: float | None = None,\n    ar: float | None = None,\n    verbose: int | None = None,\n    mem: int | None = None,\n    optim: bool = False,\n    noinsert: bool = False,\n    noswap: bool = False,\n    nomove: bool = False,\n)\n</code></pre> <p>               Bases: <code>_MmgOptionsBase</code></p> <p>Options for surface mesh remeshing (MMGS).</p> <p>All parameters are optional. When None, MMG uses its internal defaults. Options are immutable after creation.</p> Inherits from _MmgOptionsBase <p>hmin, hmax, hsiz, hausd, hgrad, hgradreq, ar, verbose, mem, optim, noinsert, noswap, nomove</p> <p>Note: Surface remeshing (MMGS) does not have a nosurf option.</p>"},{"location":"api/options/#mmgpy.MmgSOptions.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate options after initialization.</p>"},{"location":"api/options/#parameter-reference","title":"Parameter Reference","text":""},{"location":"api/options/#size-parameters","title":"Size Parameters","text":"Parameter Type Description <code>hmin</code> <code>float</code> Minimum edge length <code>hmax</code> <code>float</code> Maximum edge length <code>hsiz</code> <code>float</code> Uniform target edge length <code>hgrad</code> <code>float</code> Gradation: max ratio between adjacent edges (default: 1.3)"},{"location":"api/options/#geometric-parameters","title":"Geometric Parameters","text":"Parameter Type Description <code>hausd</code> <code>float</code> Hausdorff distance: max distance to input geometry <code>angle</code> <code>float</code> Ridge detection angle in degrees (default: 45.0)"},{"location":"api/options/#control-parameters","title":"Control Parameters","text":"Parameter Type Description <code>optim</code> <code>int</code> Optimization mode: 1 = optimize only <code>noinsert</code> <code>int</code> Disable vertex insertion: 1 = no new vertices <code>nosurf</code> <code>int</code> Preserve surface: 1 = don't move surface vertices <code>nomove</code> <code>int</code> Disable vertex motion: 1 = no vertex smoothing <code>noswap</code> <code>int</code> Disable edge swapping: 1 = no topology changes"},{"location":"api/options/#output-parameters","title":"Output Parameters","text":"Parameter Type Description <code>verbose</code> <code>int</code> Verbosity: -1=silent, 0=errors, 1=info, 2+=debug"},{"location":"api/options/#usage-examples","title":"Usage Examples","text":""},{"location":"api/options/#basic-usage","title":"Basic Usage","text":"<pre><code>from mmgpy import MmgMesh3D, Mmg3DOptions\n\nmesh = MmgMesh3D(\"input.mesh\")\n\n# Create options\nopts = Mmg3DOptions(\n    hmin=0.01,\n    hmax=0.1,\n    hausd=0.001,\n    verbose=1,\n)\n\n# Use with remesh\nresult = mesh.remesh(opts)\n</code></pre>"},{"location":"api/options/#factory-methods","title":"Factory Methods","text":"<pre><code>from mmgpy import Mmg3DOptions\n\n# Fine mesh (small elements)\nfine_opts = Mmg3DOptions.fine()\n\n# Coarse mesh (large elements)\ncoarse_opts = Mmg3DOptions.coarse()\n\n# Optimization only (no topology changes)\nopt_opts = Mmg3DOptions.optimize_only()\n</code></pre>"},{"location":"api/options/#converting-to-dictionary","title":"Converting to Dictionary","text":"<pre><code>opts = Mmg3DOptions(hmax=0.1, hausd=0.001)\n\n# Get as dictionary\nparams = opts.to_dict()\nprint(params)  # {'hmax': 0.1, 'hausd': 0.001}\n\n# Unpack into remesh\nresult = mesh.remesh(**opts.to_dict())\n</code></pre>"},{"location":"api/options/#customizing-presets","title":"Customizing Presets","text":"<pre><code>from dataclasses import replace\n\n# Start with a preset\nbase = Mmg3DOptions.fine()\n\n# Customize using replace\ncustom = replace(base, hmax=0.05, verbose=1)\n</code></pre>"},{"location":"api/options/#combining-with-keyword-arguments","title":"Combining with Keyword Arguments","text":"<p>Options objects and keyword arguments cannot be mixed:</p> <pre><code># Correct: use options object\nresult = mesh.remesh(opts)\n\n# Correct: use keyword arguments\nresult = mesh.remesh(hmax=0.1, hausd=0.001)\n\n# Error: mixing both\nresult = mesh.remesh(opts, verbose=1)  # TypeError!\n</code></pre>"},{"location":"api/options/#recommended-values","title":"Recommended Values","text":""},{"location":"api/options/#for-quality-optimization","title":"For Quality Optimization","text":"<pre><code>opts = Mmg3DOptions(\n    optim=1,       # Enable optimization mode\n    noinsert=1,    # Don't add vertices\n    hgrad=1.1,     # Gentle gradation\n)\n</code></pre>"},{"location":"api/options/#for-surface-preservation","title":"For Surface Preservation","text":"<pre><code>opts = Mmg3DOptions(\n    hmax=0.1,\n    hausd=0.0001,  # Tight approximation\n    nosurf=1,      # Preserve surface vertices\n)\n</code></pre>"},{"location":"api/options/#for-cfd-meshes","title":"For CFD Meshes","text":"<pre><code>opts = Mmg3DOptions(\n    hmin=0.001,\n    hmax=0.1,\n    hgrad=1.2,     # Smooth size transition\n    hausd=0.001,\n    angle=20.0,    # Detect more ridges\n)\n</code></pre>"},{"location":"api/options/#for-fem-meshes","title":"For FEM Meshes","text":"<pre><code>opts = Mmg3DOptions(\n    hmin=0.01,\n    hmax=0.1,\n    hgrad=1.3,\n    verbose=1,\n)\n</code></pre>"},{"location":"api/results-validation/","title":"Results &amp; Validation","text":"<p>This page documents the result and validation classes returned by mmgpy operations.</p>"},{"location":"api/results-validation/#remeshresult","title":"RemeshResult","text":"<p>Every remeshing operation returns a <code>RemeshResult</code> dataclass with statistics:</p> <p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult","title":"mmgpy.RemeshResult  <code>dataclass</code>","text":"<pre><code>RemeshResult(\n    vertices_before: int,\n    vertices_after: int,\n    elements_before: int,\n    elements_after: int,\n    triangles_before: int,\n    triangles_after: int,\n    edges_before: int,\n    edges_after: int,\n    quality_min_before: float,\n    quality_min_after: float,\n    quality_mean_before: float,\n    quality_mean_after: float,\n    duration_seconds: float,\n    warnings: tuple[str, ...],\n    return_code: int,\n)\n</code></pre> <p>Statistics from a remeshing operation.</p> <p>This class captures mesh topology changes, quality metrics, timing, and any warnings from the remeshing operation.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult--attributes","title":"Attributes","text":"<p>vertices_before : int     Number of vertices before remeshing. vertices_after : int     Number of vertices after remeshing. elements_before : int     Number of primary elements (tetrahedra for 3D, triangles for 2D/surface). elements_after : int     Number of primary elements after remeshing. triangles_before : int     Number of triangles (boundary for 3D, all for 2D/surface). triangles_after : int     Number of triangles after remeshing. edges_before : int     Number of edges before remeshing. edges_after : int     Number of edges after remeshing. quality_min_before : float     Minimum element quality before remeshing (0-1 scale). quality_min_after : float     Minimum element quality after remeshing. quality_mean_before : float     Mean element quality before remeshing. quality_mean_after : float     Mean element quality after remeshing. duration_seconds : float     Wall-clock time for the remeshing operation in seconds.     Measures only the MMG library call, excluding stats collection overhead. warnings : tuple[str, ...]     Any warnings from MMG (non-fatal issues). Currently always empty;     reserved for future implementation to capture MMG warning messages. return_code : int     MMG return code (0 = success). Note: If remeshing fails, an exception     is raised before RemeshResult is created, so this will always be 0     for successfully returned results. Included for completeness and     potential future use with partial failure modes.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult--examples","title":"Examples","text":"<p>mesh = MmgMesh3D(vertices, tetrahedra) result = mesh.remesh(hmax=0.1) print(result) RemeshResult(   vertices: 100 -&gt; 250 (+150)   elements: 400 -&gt; 1200 (+800)   quality: 0.450 -&gt; 0.780 (173.3%)   duration: 0.15s ) result.success True result.quality_improvement 1.733...</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.vertex_change","title":"vertex_change  <code>property</code>","text":"<pre><code>vertex_change: int\n</code></pre> <p>Net change in vertex count.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.element_change","title":"element_change  <code>property</code>","text":"<pre><code>element_change: int\n</code></pre> <p>Net change in element count.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.triangle_change","title":"triangle_change  <code>property</code>","text":"<pre><code>triangle_change: int\n</code></pre> <p>Net change in triangle count.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.edge_change","title":"edge_change  <code>property</code>","text":"<pre><code>edge_change: int\n</code></pre> <p>Net change in edge count.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.quality_improvement","title":"quality_improvement  <code>property</code>","text":"<pre><code>quality_improvement: float\n</code></pre> <p>Quality improvement ratio (mean_after / mean_before).</p> <p>Returns 1.0 if both values are zero (no change), inf if only before is zero, and the actual ratio otherwise.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Whether remeshing completed successfully.</p>"},{"location":"api/results-validation/#mmgpy.RemeshResult.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a readable string representation.</p>"},{"location":"api/results-validation/#usage","title":"Usage","text":"<pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\nresult = mesh.remesh(hmax=0.1)\n\n# Access statistics\nprint(f\"Vertices: {result.vertices_before} -&gt; {result.vertices_after}\")\nprint(f\"Elements: {result.elements_before} -&gt; {result.elements_after}\")\nprint(f\"Triangles: {result.triangles_before} -&gt; {result.triangles_after}\")\nprint(f\"Edges: {result.edges_before} -&gt; {result.edges_after}\")\n\n# Quality metrics\nprint(f\"Min quality: {result.quality_min_before:.3f} -&gt; {result.quality_min_after:.3f}\")\nprint(f\"Mean quality: {result.quality_mean_before:.3f} -&gt; {result.quality_mean_after:.3f}\")\n\n# Timing\nprint(f\"Duration: {result.duration_seconds:.2f}s\")\n\n# Warnings from MMG\nfor warning in result.warnings:\n    print(f\"Warning: {warning}\")\n\n# Return code\nprint(f\"Return code: {result.return_code}\")\n</code></pre>"},{"location":"api/results-validation/#validation-classes","title":"Validation Classes","text":""},{"location":"api/results-validation/#validationreport","title":"ValidationReport","text":"<p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.ValidationReport","title":"mmgpy.ValidationReport  <code>dataclass</code>","text":"<pre><code>ValidationReport(\n    is_valid: bool,\n    issues: tuple[ValidationIssue, ...],\n    quality: QualityStats | None,\n    mesh_type: str,\n)\n</code></pre> <p>Complete validation report for a mesh.</p>"},{"location":"api/results-validation/#mmgpy.ValidationReport--attributes","title":"Attributes","text":"<p>is_valid : bool     True if no errors were found (warnings are OK). issues : tuple[ValidationIssue, ...]     All validation issues found. quality : QualityStats | None     Quality statistics (None if quality check was skipped). mesh_type : str     Type of mesh that was validated.</p>"},{"location":"api/results-validation/#mmgpy.ValidationReport.errors","title":"errors  <code>property</code>","text":"<pre><code>errors: list[ValidationIssue]\n</code></pre> <p>Get all error-level issues.</p>"},{"location":"api/results-validation/#mmgpy.ValidationReport.warnings","title":"warnings  <code>property</code>","text":"<pre><code>warnings: list[ValidationIssue]\n</code></pre> <p>Get all warning-level issues.</p>"},{"location":"api/results-validation/#mmgpy.ValidationReport.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a human-readable summary.</p>"},{"location":"api/results-validation/#validationissue","title":"ValidationIssue","text":"<p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.ValidationIssue","title":"mmgpy.ValidationIssue  <code>dataclass</code>","text":"<pre><code>ValidationIssue(\n    severity: IssueSeverity,\n    check_name: str,\n    message: str,\n    element_ids: tuple[int, ...] = tuple(),\n)\n</code></pre> <p>A single validation issue found in the mesh.</p>"},{"location":"api/results-validation/#mmgpy.ValidationIssue--attributes","title":"Attributes","text":"<p>severity : IssueSeverity     Whether this is an error (mesh unusable) or warning (may cause issues). check_name : str     Name of the validation check that found this issue. message : str     Human-readable description of the issue. element_ids : tuple[int, ...]     Indices of affected elements (empty for global issues).</p>"},{"location":"api/results-validation/#qualitystats","title":"QualityStats","text":"<p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.QualityStats","title":"mmgpy.QualityStats  <code>dataclass</code>","text":"<pre><code>QualityStats(\n    min: float,\n    max: float,\n    mean: float,\n    std: float,\n    histogram: tuple[tuple[str, int], ...],\n)\n</code></pre> <p>Statistics about mesh element quality.</p> <p>Quality values are normalized to [0, 1] where 1 is a perfect element.</p>"},{"location":"api/results-validation/#mmgpy.QualityStats--attributes","title":"Attributes","text":"<p>min : float     Minimum element quality. max : float     Maximum element quality. mean : float     Mean element quality. std : float     Standard deviation of element quality. histogram : tuple[tuple[str, int], ...]     Quality distribution as (bin_label, count) pairs.</p>"},{"location":"api/results-validation/#mmgpy.QualityStats.below_threshold","title":"below_threshold","text":"<pre><code>below_threshold(threshold: float) -&gt; int\n</code></pre> <p>Count elements below a quality threshold.</p>"},{"location":"api/results-validation/#mmgpy.QualityStats.below_threshold--parameters","title":"Parameters","text":"<p>threshold : float     Quality threshold (0-1).</p>"},{"location":"api/results-validation/#mmgpy.QualityStats.below_threshold--returns","title":"Returns","text":"<p>int     Number of elements with quality below threshold.</p>"},{"location":"api/results-validation/#issueseverity","title":"IssueSeverity","text":"<p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.IssueSeverity","title":"mmgpy.IssueSeverity","text":"<p>               Bases: <code>Enum</code></p> <p>Severity level for validation issues.</p>"},{"location":"api/results-validation/#validationerror","title":"ValidationError","text":"<p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.ValidationError","title":"mmgpy.ValidationError","text":"<pre><code>ValidationError(report: ValidationReport)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raised when strict validation fails.</p> <p>Initialize with a validation report.</p>"},{"location":"api/results-validation/#validation-usage","title":"Validation Usage","text":""},{"location":"api/results-validation/#quick-validation","title":"Quick Validation","text":"<pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Returns True/False\nif mesh.validate():\n    print(\"Mesh is valid\")\nelse:\n    print(\"Mesh has issues\")\n</code></pre>"},{"location":"api/results-validation/#detailed-validation","title":"Detailed Validation","text":"<pre><code>report = mesh.validate(detailed=True)\n\nprint(f\"Valid: {report.is_valid}\")\nprint(f\"Vertices: {report.n_vertices}\")\nprint(f\"Elements: {report.n_elements}\")\nprint(f\"Triangles: {report.n_triangles}\")\n\n# Quality statistics\nprint(f\"Quality min: {report.quality.min:.3f}\")\nprint(f\"Quality max: {report.quality.max:.3f}\")\nprint(f\"Quality mean: {report.quality.mean:.3f}\")\nprint(f\"Quality std: {report.quality.std:.3f}\")\n\n# Issues\nfor issue in report.issues:\n    print(f\"[{issue.severity.name}] {issue.message}\")\n</code></pre>"},{"location":"api/results-validation/#strict-validation","title":"Strict Validation","text":"<pre><code>from mmgpy import ValidationError\n\ntry:\n    mesh.validate(strict=True)\n    print(\"Mesh passed strict validation\")\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\n    for issue in e.report.issues:\n        print(f\"  - {issue.message}\")\n</code></pre>"},{"location":"api/results-validation/#selective-validation","title":"Selective Validation","text":"<pre><code># Only check geometry\nreport = mesh.validate(\n    detailed=True,\n    check_geometry=True,\n    check_topology=False,\n    check_quality=False,\n)\n\n# Only check quality with custom threshold\nreport = mesh.validate(\n    detailed=True,\n    check_geometry=False,\n    check_topology=False,\n    check_quality=True,\n    min_quality=0.2,  # Custom threshold\n)\n</code></pre>"},{"location":"api/results-validation/#validation-functions","title":"Validation Functions","text":"<p>For direct validation without mesh methods:</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_3d","title":"mmgpy.validate_mesh_3d","text":"<pre><code>validate_mesh_3d(\n    mesh: MmgMesh3D,\n    *,\n    check_geometry: bool = True,\n    check_topology: bool = True,\n    check_quality: bool = True,\n    min_quality: float = 0.1,\n) -&gt; ValidationReport\n</code></pre> <p>Validate a 3D tetrahedral mesh.</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_3d--parameters","title":"Parameters","text":"<p>mesh : MmgMesh3D     The mesh to validate. check_geometry : bool     Check for geometric issues (inverted/degenerate elements). check_topology : bool     Check for topological issues (orphan vertices). check_quality : bool     Check element quality against threshold. min_quality : float     Minimum acceptable element quality (0-1).</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_3d--returns","title":"Returns","text":"<p>ValidationReport     Complete validation report.</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_2d","title":"mmgpy.validate_mesh_2d","text":"<pre><code>validate_mesh_2d(\n    mesh: MmgMesh2D,\n    *,\n    check_geometry: bool = True,\n    check_topology: bool = True,\n    check_quality: bool = True,\n    min_quality: float = 0.1,\n) -&gt; ValidationReport\n</code></pre> <p>Validate a 2D planar mesh.</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_2d--parameters","title":"Parameters","text":"<p>mesh : MmgMesh2D     The mesh to validate. check_geometry : bool     Check for geometric issues (inverted/degenerate elements). check_topology : bool     Check for topological issues (orphan vertices, non-manifold edges). check_quality : bool     Check element quality against threshold. min_quality : float     Minimum acceptable element quality (0-1).</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_2d--returns","title":"Returns","text":"<p>ValidationReport     Complete validation report.</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_surface","title":"mmgpy.validate_mesh_surface","text":"<pre><code>validate_mesh_surface(\n    mesh: MmgMeshS,\n    *,\n    check_geometry: bool = True,\n    check_topology: bool = True,\n    check_quality: bool = True,\n    min_quality: float = 0.1,\n) -&gt; ValidationReport\n</code></pre> <p>Validate a surface mesh.</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_surface--parameters","title":"Parameters","text":"<p>mesh : MmgMeshS     The mesh to validate. check_geometry : bool     Check for geometric issues (degenerate elements). check_topology : bool     Check for topological issues (orphan vertices, non-manifold edges). check_quality : bool     Check element quality against threshold. min_quality : float     Minimum acceptable element quality (0-1).</p>"},{"location":"api/results-validation/#mmgpy.validate_mesh_surface--returns","title":"Returns","text":"<p>ValidationReport     Complete validation report.</p>"},{"location":"api/results-validation/#direct-function-usage","title":"Direct Function Usage","text":"<pre><code>from mmgpy import validate_mesh_3d, MmgMesh3D\n\nmesh = MmgMesh3D(\"input.mesh\")\n\nreport = validate_mesh_3d(\n    mesh,\n    check_geometry=True,\n    check_topology=True,\n    check_quality=True,\n    min_quality=0.1,\n)\n\nprint(f\"Valid: {report.is_valid}\")\n</code></pre>"},{"location":"api/results-validation/#complete-example","title":"Complete Example","text":"<pre><code>import mmgpy\nfrom mmgpy import ValidationError\n\n# Load mesh\nmesh = mmgpy.read(\"input.mesh\")\n\n# Initial validation\ninitial = mesh.validate(detailed=True)\nprint(f\"Initial quality: {initial.quality.mean:.3f}\")\n\nif not initial.is_valid:\n    print(\"Initial mesh has issues:\")\n    for issue in initial.issues:\n        print(f\"  - {issue.message}\")\n\n# Remesh\nresult = mesh.remesh(hmax=0.1, verbose=-1)\n\n# Post-remesh validation\ntry:\n    mesh.validate(strict=True)\n    print(\"Remeshed mesh is valid\")\nexcept ValidationError as e:\n    print(f\"Remeshed mesh has issues: {len(e.report.issues)}\")\n\n# Final report\nfinal = mesh.validate(detailed=True)\nprint(f\"\\nQuality improved: {initial.quality.mean:.3f} -&gt; {final.quality.mean:.3f}\")\nprint(f\"Elements: {initial.n_elements} -&gt; {final.n_elements}\")\n</code></pre>"},{"location":"api/sizing/","title":"Sizing Constraints","text":"<p>This page documents the sizing constraint classes for local mesh refinement.</p>"},{"location":"api/sizing/#overview","title":"Overview","text":"<p>Sizing constraints define regions where specific element sizes should be used. Multiple constraints can be combined - where they overlap, the minimum size wins.</p>"},{"location":"api/sizing/#sizing-classes","title":"Sizing Classes","text":""},{"location":"api/sizing/#spheresize","title":"SphereSize","text":"<p>options: show_root_heading: true</p>"},{"location":"api/sizing/#mmgpy.SphereSize","title":"mmgpy.SphereSize  <code>dataclass</code>","text":"<pre><code>SphereSize(center: NDArray[float64], radius: float, size: float)\n</code></pre> <p>               Bases: <code>SizingConstraint</code></p> <p>Uniform size within a spherical region.</p>"},{"location":"api/sizing/#mmgpy.SphereSize--parameters","title":"Parameters","text":"<p>center : array_like     Center of the sphere, shape (dim,). radius : float     Radius of the sphere. Must be positive. size : float     Target edge size within the sphere. Must be positive.</p>"},{"location":"api/sizing/#boxsize","title":"BoxSize","text":"<p>options: show_root_heading: true</p>"},{"location":"api/sizing/#mmgpy.BoxSize","title":"mmgpy.BoxSize  <code>dataclass</code>","text":"<pre><code>BoxSize(bounds: NDArray[float64], size: float)\n</code></pre> <p>               Bases: <code>SizingConstraint</code></p> <p>Uniform size within a box region.</p>"},{"location":"api/sizing/#mmgpy.BoxSize--parameters","title":"Parameters","text":"<p>bounds : array_like     Box bounds as [[xmin, ymin, zmin], [xmax, ymax, zmax]] for 3D     or [[xmin, ymin], [xmax, ymax]] for 2D. size : float     Target edge size within the box. Must be positive.</p>"},{"location":"api/sizing/#cylindersize","title":"CylinderSize","text":"<p>options: show_root_heading: true</p>"},{"location":"api/sizing/#mmgpy.CylinderSize","title":"mmgpy.CylinderSize  <code>dataclass</code>","text":"<pre><code>CylinderSize(\n    point1: NDArray[float64], point2: NDArray[float64], radius: float, size: float\n)\n</code></pre> <p>               Bases: <code>SizingConstraint</code></p> <p>Uniform size within a cylindrical region.</p>"},{"location":"api/sizing/#mmgpy.CylinderSize--parameters","title":"Parameters","text":"<p>point1 : array_like     First endpoint of cylinder axis, shape (3,). point2 : array_like     Second endpoint of cylinder axis, shape (3,). radius : float     Radius of the cylinder. Must be positive. size : float     Target edge size within the cylinder. Must be positive.</p>"},{"location":"api/sizing/#pointsize","title":"PointSize","text":"<p>options: show_root_heading: true</p>"},{"location":"api/sizing/#mmgpy.PointSize","title":"mmgpy.PointSize  <code>dataclass</code>","text":"<pre><code>PointSize(\n    point: NDArray[float64], near_size: float, far_size: float, influence_radius: float\n)\n</code></pre> <p>               Bases: <code>SizingConstraint</code></p> <p>Distance-based sizing from a point.</p> <p>Size varies linearly from near_size at the point to far_size at influence_radius distance.</p>"},{"location":"api/sizing/#mmgpy.PointSize--parameters","title":"Parameters","text":"<p>point : array_like     Reference point, shape (dim,). near_size : float     Target size at the reference point. Must be positive. far_size : float     Target size at influence_radius distance and beyond. Must be positive. influence_radius : float     Distance over which size transitions from near_size to far_size.     Must be positive.</p>"},{"location":"api/sizing/#sizingconstraint-base-class","title":"SizingConstraint (Base Class)","text":"<p>options: show_root_heading: true</p>"},{"location":"api/sizing/#mmgpy.SizingConstraint","title":"mmgpy.SizingConstraint  <code>dataclass</code>","text":"<pre><code>SizingConstraint()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for sizing constraints.</p>"},{"location":"api/sizing/#mmgpy.SizingConstraint.compute_sizes","title":"compute_sizes  <code>abstractmethod</code>","text":"<pre><code>compute_sizes(vertices: NDArray[float64]) -&gt; NDArray[np.float64]\n</code></pre> <p>Compute target size at each vertex.</p>"},{"location":"api/sizing/#mmgpy.SizingConstraint.compute_sizes--parameters","title":"Parameters","text":"<p>vertices : NDArray[np.float64]     Vertex coordinates, shape (n_vertices, dim).</p>"},{"location":"api/sizing/#mmgpy.SizingConstraint.compute_sizes--returns","title":"Returns","text":"<p>NDArray[np.float64]     Target size at each vertex, shape (n_vertices,).     Use np.inf for vertices where this constraint doesn't apply.</p>"},{"location":"api/sizing/#mesh-methods","title":"Mesh Methods","text":"<p>All mesh classes have convenience methods for adding sizing constraints:</p>"},{"location":"api/sizing/#set_size_sphere","title":"set_size_sphere","text":"<pre><code>mesh.set_size_sphere(\n    center=[0.5, 0.5, 0.5],  # Center of sphere\n    radius=0.2,              # Sphere radius\n    size=0.01,               # Target edge size\n)\n</code></pre>"},{"location":"api/sizing/#set_size_box","title":"set_size_box","text":"<pre><code>mesh.set_size_box(\n    bounds=[[0, 0, 0], [0.3, 0.3, 0.3]],  # [[min], [max]]\n    size=0.01,\n)\n</code></pre>"},{"location":"api/sizing/#set_size_cylinder","title":"set_size_cylinder","text":"<pre><code># 3D meshes only\nmesh.set_size_cylinder(\n    point1=[0, 0, 0],    # First axis endpoint\n    point2=[0, 0, 1],    # Second axis endpoint\n    radius=0.1,          # Cylinder radius\n    size=0.01,\n)\n</code></pre>"},{"location":"api/sizing/#set_size_from_point","title":"set_size_from_point","text":"<pre><code>mesh.set_size_from_point(\n    point=[0.5, 0.5, 0.5],\n    near_size=0.01,       # Size at reference point\n    far_size=0.1,         # Size at influence_radius\n    influence_radius=0.5,\n)\n</code></pre>"},{"location":"api/sizing/#clear_local_sizing","title":"clear_local_sizing","text":"<pre><code># Remove all sizing constraints\nmesh.clear_local_sizing()\n</code></pre>"},{"location":"api/sizing/#get_local_sizing_count","title":"get_local_sizing_count","text":"<pre><code># Check number of active constraints\nn = mesh.get_local_sizing_count()\n</code></pre>"},{"location":"api/sizing/#apply_local_sizing","title":"apply_local_sizing","text":"<pre><code># Manually apply constraints to metric field\nmesh.apply_local_sizing()\n</code></pre>"},{"location":"api/sizing/#utility-functions","title":"Utility Functions","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api/sizing/#mmgpy.sizing.apply_sizing_constraints","title":"mmgpy.sizing.apply_sizing_constraints","text":"<pre><code>apply_sizing_constraints(\n    mesh: MmgMesh3D | MmgMesh2D | MmgMeshS,\n    constraints: list[SizingConstraint],\n    existing_metric: NDArray[float64] | None = None,\n) -&gt; None\n</code></pre> <p>Apply sizing constraints to a mesh by setting its metric field.</p>"},{"location":"api/sizing/#mmgpy.sizing.apply_sizing_constraints--parameters","title":"Parameters","text":"<p>mesh : MmgMesh3D | MmgMesh2D | MmgMeshS     Mesh to apply sizing to. constraints : list[SizingConstraint]     List of sizing constraints. existing_metric : NDArray[np.float64] | None     Existing metric field to combine with. If provided, minimum size wins.</p>"},{"location":"api/sizing/#mmgpy.sizing.compute_sizes_from_constraints","title":"mmgpy.sizing.compute_sizes_from_constraints","text":"<pre><code>compute_sizes_from_constraints(\n    vertices: NDArray[float64], constraints: list[SizingConstraint]\n) -&gt; NDArray[np.float64]\n</code></pre> <p>Compute combined sizing from multiple constraints.</p> <p>Multiple constraints are combined by taking the minimum size at each vertex (finest mesh wins).</p>"},{"location":"api/sizing/#mmgpy.sizing.compute_sizes_from_constraints--parameters","title":"Parameters","text":"<p>vertices : NDArray[np.float64]     Vertex coordinates, shape (n_vertices, dim). constraints : list[SizingConstraint]     List of sizing constraints.</p>"},{"location":"api/sizing/#mmgpy.sizing.compute_sizes_from_constraints--returns","title":"Returns","text":"<p>NDArray[np.float64]     Combined target size at each vertex, shape (n_vertices,).</p>"},{"location":"api/sizing/#mmgpy.sizing.sizes_to_metric","title":"mmgpy.sizing.sizes_to_metric","text":"<pre><code>sizes_to_metric(sizes: NDArray[float64]) -&gt; NDArray[np.float64]\n</code></pre> <p>Convert scalar sizes to metric tensor format.</p>"},{"location":"api/sizing/#mmgpy.sizing.sizes_to_metric--parameters","title":"Parameters","text":"<p>sizes : NDArray[np.float64]     Target sizes at each vertex, shape (n_vertices,).</p>"},{"location":"api/sizing/#mmgpy.sizing.sizes_to_metric--returns","title":"Returns","text":"<p>NDArray[np.float64]     Metric field suitable for mesh[\"metric\"], shape (n_vertices, 1).</p>"},{"location":"api/sizing/#usage-examples","title":"Usage Examples","text":""},{"location":"api/sizing/#basic-usage","title":"Basic Usage","text":"<pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Add refinement region\nmesh.set_size_sphere(center=[0.5, 0.5, 0.5], radius=0.2, size=0.01)\n\n# Remesh (sizing constraints applied automatically)\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"api/sizing/#multiple-regions","title":"Multiple Regions","text":"<pre><code># Fine region\nmesh.set_size_sphere(center=[0.3, 0.5, 0.5], radius=0.1, size=0.005)\n\n# Medium region\nmesh.set_size_box(bounds=[[0.5, 0, 0], [1, 1, 1]], size=0.02)\n\n# Graded region\nmesh.set_size_from_point(\n    point=[0.8, 0.5, 0.5],\n    near_size=0.01,\n    far_size=0.05,\n    influence_radius=0.3,\n)\n\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"api/sizing/#direct-class-usage","title":"Direct Class Usage","text":"<pre><code>from mmgpy import SphereSize, BoxSize\nfrom mmgpy.sizing import apply_sizing_constraints\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\n\nconstraints = [\n    SphereSize(\n        center=np.array([0.5, 0.5, 0.5]),\n        radius=0.2,\n        size=0.01,\n    ),\n    BoxSize(\n        bounds=np.array([[0, 0, 0], [0.3, 0.3, 0.3]]),\n        size=0.02,\n    ),\n]\n\napply_sizing_constraints(mesh, constraints)\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"api/sizing/#workflow-with-validation","title":"Workflow with Validation","text":"<pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Add sizing constraints\nmesh.set_size_sphere(center=[0.5, 0.5, 0.5], radius=0.2, size=0.01)\n\n# Check constraint count\nprint(f\"Active constraints: {mesh.get_local_sizing_count()}\")\n\n# Preview metric field\nmesh.apply_local_sizing()\nmetric = mesh[\"metric\"]\nprint(f\"Metric sizes: {metric.min():.4f} to {metric.max():.4f}\")\n\n# Remesh\nresult = mesh.remesh(hmax=0.1, verbose=-1)\n\n# Clear for next iteration\nmesh.clear_local_sizing()\n</code></pre>"},{"location":"api/sizing/#how-sizing-works","title":"How Sizing Works","text":"<ol> <li>Constraint Definition: Each constraint defines a region and target size</li> <li>Size Computation: For each vertex, compute size from all constraints</li> <li>Minimum Selection: Where constraints overlap, minimum size wins</li> <li>Metric Conversion: Sizes are converted to isotropic metric tensors</li> <li>Remeshing: MMG uses the metric field to guide remeshing</li> </ol> <pre><code>from mmgpy.sizing import compute_sizes_from_constraints, sizes_to_metric\nimport numpy as np\n\n# Get vertex coordinates\nvertices = mesh.get_vertices()\n\n# Compute sizes from constraints\nconstraints = [SphereSize(...), BoxSize(...)]\nsizes = compute_sizes_from_constraints(vertices, constraints)\n\n# Convert to metric field\nmetric = sizes_to_metric(sizes)\n\n# Apply to mesh\nmesh[\"metric\"] = metric\n</code></pre>"},{"location":"api/sizing/#tips","title":"Tips","text":"<ol> <li>Constraint Order: Order doesn't matter - minimum size wins everywhere</li> <li>Performance: Many constraints have minimal overhead</li> <li>Clearing: Always clear constraints between different remeshing runs if needed</li> <li>Debugging: Use <code>apply_local_sizing()</code> to preview the metric field before remeshing</li> </ol>"},{"location":"examples/","title":"Examples Gallery","text":"<p>This page showcases complete examples from the mmgpy repository.</p>"},{"location":"examples/#3d-volume-meshing-mmg3d","title":"3D Volume Meshing (mmg3d)","text":""},{"location":"examples/#mesh-quality-improvement","title":"Mesh Quality Improvement","text":"<p>Improve mesh quality without changing topology.</p> <pre><code>\"\"\"Mesh quality improvement with mean edge length preservation.\"\"\"\nimport mmgpy\n\n# Load mesh\nmesh = mmgpy.MmgMesh3D(\"input.mesh\")\n\n# Optimize quality only (no vertex insertion/removal)\nresult = mesh.remesh_optimize()\n\nprint(f\"Quality: {result.quality_mean_before:.3f} -&gt; {result.quality_mean_after:.3f}\")\n</code></pre> <p>View full example</p>"},{"location":"examples/#open-boundary-remeshing","title":"Open Boundary Remeshing","text":"<p>Remesh volumetric mesh with open boundaries.</p> <pre><code>\"\"\"Remeshing with open boundary handling.\"\"\"\nimport mmgpy\n\nmesh = mmgpy.MmgMesh3D(\"domain_with_holes.mesh\")\n\nresult = mesh.remesh(\n    hmax=0.1,\n    hausd=0.001,\n)\n</code></pre> <p>View full example</p>"},{"location":"examples/#lagrangian-motion","title":"Lagrangian Motion","text":"<p>Remesh while applying mesh displacement.</p> <pre><code>\"\"\"Lagrangian mesh motion remeshing.\"\"\"\nimport mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMesh3D(\"input.mesh\")\nvertices = mesh.get_vertices()\n\n# Define displacement field\ndisplacement = np.zeros_like(vertices)\ndisplacement[:, 0] = 0.1 * np.sin(vertices[:, 1] * np.pi)\n\n# Remesh with motion\nresult = mesh.remesh_lagrangian(displacement)\n</code></pre> <p>View full example</p>"},{"location":"examples/#level-set-discretization","title":"Level-Set Discretization","text":"<p>Extract isosurface from implicit function.</p> <pre><code>\"\"\"Level-set based surface extraction.\"\"\"\nimport mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMesh3D(\"background.mesh\")\nvertices = mesh.get_vertices()\n\n# Sphere level-set\nlevelset = np.linalg.norm(vertices - [0.5, 0.5, 0.5], axis=1) - 0.3\n\nresult = mesh.remesh_levelset(levelset)\n</code></pre> <p>View full example</p>"},{"location":"examples/#2d-meshing-mmg2d","title":"2D Meshing (mmg2d)","text":""},{"location":"examples/#local-sizing-control","title":"Local Sizing Control","text":"<p>Apply regional mesh refinement.</p> <pre><code>\"\"\"Per-region mesh density control.\"\"\"\nimport mmgpy\n\nmesh = mmgpy.MmgMesh2D(\"domain.mesh\")\n\n# Fine mesh in center\nmesh.set_size_sphere(center=[0.5, 0.5], radius=0.2, size=0.01)\n\n# Coarser mesh elsewhere\nresult = mesh.remesh(hmax=0.1)\n</code></pre> <p>View full example</p>"},{"location":"examples/#solution-based-adaptation","title":"Solution-Based Adaptation","text":"<p>Adapt mesh to solution field.</p> <pre><code>\"\"\"Mesh adaptation to solution gradients.\"\"\"\nimport mmgpy\nimport mmgpy.metrics as metrics\nimport numpy as np\n\nmesh = mmgpy.MmgMesh2D(\"domain.mesh\")\nvertices = mesh.get_vertices()\n\n# Solution field\nsolution = np.sin(vertices[:, 0] * 4 * np.pi) * np.cos(vertices[:, 1] * 4 * np.pi)\n\n# Create metric from solution gradients\n# (simplified - full implementation computes Hessian)\nsizes = 0.01 + 0.1 * np.abs(solution)\nmetric = metrics.create_isotropic_metric(sizes)\nmesh[\"metric\"] = metric\n\nresult = mesh.remesh()\n</code></pre> <p>View full example</p>"},{"location":"examples/#anisotropic-mesh-adaptation","title":"Anisotropic Mesh Adaptation","text":"<p>Directional mesh refinement.</p> <pre><code>\"\"\"Anisotropic mesh adaptation.\"\"\"\nimport mmgpy\nimport mmgpy.metrics as metrics\nimport numpy as np\n\nmesh = mmgpy.MmgMesh2D(\"domain.mesh\")\nn_vertices = mesh.get_mesh_size()[\"vertices\"]\n\n# Create anisotropic metric (stretch in x direction)\ndirections = np.tile(np.eye(2), (n_vertices, 1, 1))\nsizes = np.tile([0.1, 0.02], (n_vertices, 1))  # Larger in x, smaller in y\n\nmetric = metrics.create_anisotropic_metric(directions, sizes)\nmesh[\"metric\"] = metric\n\nresult = mesh.remesh()\n</code></pre> <p>View full example</p>"},{"location":"examples/#implicit-2d-domain-meshing","title":"Implicit 2D Domain Meshing","text":"<p>Generate mesh from implicit function.</p> <pre><code>\"\"\"Generate 2D mesh from implicit domain definition.\"\"\"\nimport mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMesh2D(\"background.mesh\")\nvertices = mesh.get_vertices()\n\n# Circle level-set\nlevelset = np.linalg.norm(vertices[:, :2] - [0.5, 0.5], axis=1) - 0.3\n\nresult = mesh.remesh_levelset(levelset)\n</code></pre> <p>View full example</p>"},{"location":"examples/#surface-meshing-mmgs","title":"Surface Meshing (mmgs)","text":""},{"location":"examples/#mechanical-piece-remeshing","title":"Mechanical Piece Remeshing","text":"<p>Industrial part surface remeshing.</p> <pre><code>\"\"\"Mechanical part surface optimization.\"\"\"\nimport mmgpy\n\nmesh = mmgpy.MmgMeshS(\"part.stl\")\n\nresult = mesh.remesh(\n    hmax=0.05,\n    hausd=0.001,\n    angle=30.0,  # Preserve sharp edges\n)\n</code></pre> <p></p> <p>View full example</p>"},{"location":"examples/#smooth-surface-remeshing","title":"Smooth Surface Remeshing","text":"<p>Surface smoothing and refinement.</p> <pre><code>\"\"\"Smooth surface mesh optimization.\"\"\"\nimport mmgpy\n\nmesh = mmgpy.MmgMeshS(\"surface.mesh\")\n\nresult = mesh.remesh(\n    hmax=0.1,\n    hausd=0.0001,  # Tight approximation\n    hgrad=1.1,     # Smooth gradation\n)\n</code></pre> <p></p> <p>View full example</p>"},{"location":"examples/#implicit-surface-meshing","title":"Implicit Surface Meshing","text":"<p>Generate surface from implicit function.</p> <pre><code>\"\"\"Generate surface mesh from implicit function.\"\"\"\nimport mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMeshS(\"background_surface.mesh\")\nvertices = mesh.get_vertices()\n\n# Torus level-set\nR, r = 0.5, 0.15\nx, y, z = vertices[:, 0] - 0.5, vertices[:, 1] - 0.5, vertices[:, 2] - 0.5\nq = np.sqrt(x**2 + y**2) - R\nlevelset = np.sqrt(q**2 + z**2) - r\n\nresult = mesh.remesh_levelset(levelset)\n</code></pre> <p>View full example</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>Clone the repository and run examples:</p> <pre><code>git clone https://github.com/kmarchais/mmgpy.git\ncd mmgpy\n\n# Install with examples dependencies\npip install -e \".[dev]\"\n\n# Run an example\npython examples/mmgs/mechanical_piece_remeshing.py\n</code></pre> <p>Each example includes detailed comments and visualization using PyVista.</p>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":"<p>This page explains the fundamental concepts behind mmgpy and mesh remeshing.</p>"},{"location":"getting-started/concepts/#mesh-types","title":"Mesh Types","text":"<p>mmgpy supports three types of meshes:</p>"},{"location":"getting-started/concepts/#3d-volumetric-meshes-mmgmesh3d","title":"3D Volumetric Meshes (<code>MmgMesh3D</code>)","text":"<p>Tetrahedral meshes representing 3D volumes. Used for:</p> <ul> <li>Finite element analysis (FEA)</li> <li>Computational fluid dynamics (CFD)</li> <li>Structural simulations</li> </ul> <pre><code>import mmgpy\n\n# Load a volumetric mesh\nmesh = mmgpy.MmgMesh3D(\"volume.mesh\")\n</code></pre>"},{"location":"getting-started/concepts/#2d-planar-meshes-mmgmesh2d","title":"2D Planar Meshes (<code>MmgMesh2D</code>)","text":"<p>Triangular meshes in 2D. Used for:</p> <ul> <li>2D simulations</li> <li>Planar domain meshing</li> <li>Height field representations</li> </ul> <pre><code>import mmgpy\n\nmesh = mmgpy.MmgMesh2D(\"planar.mesh\")\n</code></pre>"},{"location":"getting-started/concepts/#3d-surface-meshes-mmgmeshs","title":"3D Surface Meshes (<code>MmgMeshS</code>)","text":"<p>Triangular meshes representing 3D surfaces. Used for:</p> <ul> <li>Surface remeshing</li> <li>CAD model preparation</li> <li>Graphics and visualization</li> </ul> <pre><code>import mmgpy\n\nmesh = mmgpy.MmgMeshS(\"surface.stl\")\n</code></pre>"},{"location":"getting-started/concepts/#the-unified-mesh-class","title":"The Unified Mesh Class","text":"<p>For convenience, mmgpy provides a unified <code>Mesh</code> class that auto-detects the mesh type:</p> <pre><code>import mmgpy\n\n# Auto-detect mesh type from file\nmesh = mmgpy.read(\"input.mesh\")\nprint(f\"Mesh type: {mesh.kind}\")  # MeshKind.TETRAHEDRAL, TRIANGULAR_2D, or TRIANGULAR_SURFACE\n</code></pre>"},{"location":"getting-started/concepts/#remeshing-operations","title":"Remeshing Operations","text":""},{"location":"getting-started/concepts/#standard-remeshing","title":"Standard Remeshing","text":"<p>The default <code>remesh()</code> operation modifies the mesh topology to achieve target element sizes:</p> <pre><code>result = mesh.remesh(\n    hmin=0.01,   # Minimum edge length\n    hmax=0.1,    # Maximum edge length\n)\n</code></pre> <p>This may:</p> <ul> <li>Insert new vertices</li> <li>Remove vertices</li> <li>Swap edges</li> <li>Split/collapse elements</li> </ul>"},{"location":"getting-started/concepts/#optimization-only","title":"Optimization Only","text":"<p>To improve quality without changing topology:</p> <pre><code>result = mesh.remesh_optimize()\n</code></pre> <p>Or equivalently:</p> <pre><code>result = mesh.remesh(optim=1, noinsert=1)\n</code></pre>"},{"location":"getting-started/concepts/#uniform-remeshing","title":"Uniform Remeshing","text":"<p>To remesh with a single target size everywhere:</p> <pre><code>result = mesh.remesh_uniform(size=0.05)\n</code></pre>"},{"location":"getting-started/concepts/#level-set-remeshing","title":"Level-Set Remeshing","text":"<p>Extract and remesh an isosurface:</p> <pre><code>import numpy as np\n\n# Define a level-set function (distance to sphere)\ndef levelset_func(coords):\n    return np.linalg.norm(coords - [0.5, 0.5, 0.5], axis=1) - 0.3\n\nmesh = mmgpy.MmgMesh3D(\"background.mesh\")\nlevelset = levelset_func(mesh.get_vertices())\n\nresult = mesh.remesh_levelset(levelset)\n</code></pre>"},{"location":"getting-started/concepts/#lagrangian-remeshing","title":"Lagrangian Remeshing","text":"<p>Remesh while preserving a displacement field (useful for moving meshes):</p> <pre><code># Displacement field at each vertex\ndisplacement = np.zeros((n_vertices, 3))\ndisplacement[:, 0] = 0.1  # Move all vertices in x\n\nresult = mesh.remesh_lagrangian(displacement)\n</code></pre>"},{"location":"getting-started/concepts/#mesh-size-control","title":"Mesh Size Control","text":""},{"location":"getting-started/concepts/#global-sizing","title":"Global Sizing","text":"<p>Control edge lengths globally:</p> Parameter Description <code>hmin</code> Minimum edge length <code>hmax</code> Maximum edge length <code>hsiz</code> Uniform target edge length <code>hausd</code> Hausdorff distance (geometric approximation)"},{"location":"getting-started/concepts/#local-sizing","title":"Local Sizing","text":"<p>Refine specific regions with sizing constraints:</p> <pre><code># Spherical refinement region\nmesh.set_size_sphere(center=[0.5, 0.5, 0.5], radius=0.2, size=0.01)\n\n# Box refinement region\nmesh.set_size_box(bounds=[[0, 0, 0], [0.3, 0.3, 0.3]], size=0.02)\n\n# Cylindrical refinement region (3D only)\nmesh.set_size_cylinder(point1=[0, 0, 0], point2=[1, 0, 0], radius=0.1, size=0.01)\n\n# Distance-based sizing from a point\nmesh.set_size_from_point(\n    point=[0.5, 0.5, 0.5],\n    near_size=0.01,\n    far_size=0.1,\n    influence_radius=0.5,\n)\n</code></pre>"},{"location":"getting-started/concepts/#metric-fields","title":"Metric Fields","text":"<p>For anisotropic remeshing, define a metric tensor at each vertex:</p> <pre><code>import mmgpy.metrics as metrics\n\n# Create isotropic metric from sizes\nsizes = np.ones(n_vertices) * 0.1\nmetric = metrics.create_isotropic_metric(sizes)\nmesh[\"metric\"] = metric\n\nresult = mesh.remesh()\n</code></pre>"},{"location":"getting-started/concepts/#quality-metrics","title":"Quality Metrics","text":"<p>mmgpy uses normalized quality measures:</p> <ul> <li>Quality = 1.0 - Perfect element (equilateral tetrahedron/triangle)</li> <li>Quality = 0.0 - Degenerate element (collapsed)</li> </ul> <p>The <code>RemeshResult</code> class provides quality statistics:</p> <pre><code>result = mesh.remesh(hmax=0.1)\n\nprint(f\"Min quality: {result.quality_min_after:.3f}\")\nprint(f\"Mean quality: {result.quality_mean_after:.3f}\")\n</code></pre>"},{"location":"getting-started/concepts/#file-formats","title":"File Formats","text":"<p>mmgpy supports 40+ file formats via meshio:</p> Format Extension Notes MMG native <code>.mesh</code> Recommended for MMG VTK <code>.vtk</code>, <code>.vtu</code> Good for ParaView STL <code>.stl</code> Surface meshes only OBJ <code>.obj</code> Surface meshes only GMSH <code>.msh</code> Popular for FEM PLY <code>.ply</code> Point cloud/mesh <p>Load any format with <code>mmgpy.read()</code>:</p> <pre><code>mesh = mmgpy.read(\"model.stl\")\nmesh.save(\"output.vtk\")\n</code></pre>"},{"location":"getting-started/concepts/#verbosity-levels","title":"Verbosity Levels","text":"<p>Control output verbosity:</p> Level Description <code>-1</code> Silent (no output) <code>0</code> Errors only <code>1</code> Standard info <code>2+</code> Debug output <pre><code>result = mesh.remesh(hmax=0.1, verbose=-1)  # Silent\nresult = mesh.remesh(hmax=0.1, verbose=1)   # Standard\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>A supported operating system: Windows, macOS, or Linux</li> </ul>"},{"location":"getting-started/installation/#installing-from-pypi","title":"Installing from PyPI","text":"<p>The easiest way to install mmgpy is from PyPI:</p> pipuvpipx (CLI only) <pre><code>pip install mmgpy\n</code></pre> <pre><code>uv pip install mmgpy\n</code></pre> <pre><code>pipx install mmgpy\n</code></pre> <p>Pre-built wheels are available for:</p> Platform Architectures Windows x86_64 macOS arm64, x86_64 Linux x86_64, aarch64"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":"<p>To install the latest development version:</p> <pre><code>pip install git+https://github.com/kmarchais/mmgpy.git\n</code></pre>"},{"location":"getting-started/installation/#build-requirements","title":"Build Requirements","text":"<p>Building from source requires:</p> <ul> <li>CMake &gt;= 3.15</li> <li>C++ compiler with C++17 support</li> <li>pybind11 &gt;= 3.0.0</li> <li>scikit-build-core &gt;= 0.11.5</li> </ul>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that mmgpy is working correctly:</p> <pre><code>import mmgpy\n\nprint(f\"mmgpy version: {mmgpy.__version__}\")\nprint(f\"MMG version: {mmgpy.MMG_VERSION}\")\n</code></pre> <p>Test basic functionality:</p> <pre><code>import mmgpy\nimport numpy as np\n\n# Create a simple tetrahedral mesh\nvertices = np.array([\n    [0, 0, 0],\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n], dtype=np.float64)\n\ntetrahedra = np.array([[0, 1, 2, 3]], dtype=np.int32)\n\nmesh = mmgpy.MmgMesh3D(vertices, tetrahedra)\nprint(f\"Created mesh with {mesh.get_mesh_size()['vertices']} vertices\")\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>mmgpy works with several visualization and mesh I/O libraries:</p> Package Purpose pyvista 3D visualization and mesh conversion meshio Extended file format support rich Progress bars and formatted output <p>These are installed automatically with mmgpy.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-errors-on-windows","title":"Import Errors on Windows","text":"<p>If you encounter DLL loading errors on Windows:</p> <ol> <li>Ensure Visual C++ Redistributable is installed</li> <li>Try enabling debug mode to see DLL search paths:</li> </ol> <pre><code>import mmgpy\nmmgpy.enable_debug()\n</code></pre>"},{"location":"getting-started/installation/#rpath-issues-on-macoslinux","title":"RPATH Issues on macOS/Linux","text":"<p>If the bundled executables (<code>mmg2d_O3</code>, <code>mmg3d_O3</code>, <code>mmgs_O3</code>) fail to run:</p> <pre><code># Run the RPATH fix utility\nfix-mmg-rpath\n</code></pre> <p>Or from Python:</p> <pre><code>from mmgpy import _fix_rpath\n_fix_rpath()\n</code></pre>"},{"location":"getting-started/installation/#debug-logging","title":"Debug Logging","text":"<p>Enable detailed logging to diagnose issues:</p> <pre><code>import mmgpy\n\nmmgpy.enable_debug()  # Show all debug messages\n# or\nmmgpy.set_log_level(\"DEBUG\")  # Equivalent\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with mmgpy in 5 minutes.</p>"},{"location":"getting-started/quickstart/#your-first-remesh","title":"Your First Remesh","text":"<p>The simplest way to use mmgpy is to load a mesh, remesh it, and save the result:</p> <pre><code>import mmgpy\n\n# Load a mesh from any supported format\nmesh = mmgpy.read(\"input.mesh\")\n\n# Remesh with a target edge size\nresult = mesh.remesh(hmax=0.1)\n\n# Check the results\nprint(f\"Vertices: {result.vertices_before} -&gt; {result.vertices_after}\")\nprint(f\"Quality: {result.quality_mean_before:.3f} -&gt; {result.quality_mean_after:.3f}\")\n\n# Save to any supported format\nmesh.save(\"output.vtk\")\n</code></pre>"},{"location":"getting-started/quickstart/#using-options-objects","title":"Using Options Objects","text":"<p>For more control, use typed options objects with IDE autocomplete:</p> 3D Mesh2D MeshSurface Mesh <pre><code>from mmgpy import Mmg3DOptions, read\n\nmesh = read(\"volume.mesh\")\n\nopts = Mmg3DOptions(\n    hmin=0.01,       # Minimum edge size\n    hmax=0.1,        # Maximum edge size\n    hausd=0.001,     # Geometric approximation tolerance\n    verbose=1,       # Show progress\n)\n\nresult = mesh.remesh(opts)\n</code></pre> <pre><code>from mmgpy import Mmg2DOptions, read\n\nmesh = read(\"planar.mesh\")\n\nopts = Mmg2DOptions(\n    hmin=0.01,\n    hmax=0.1,\n    verbose=1,\n)\n\nresult = mesh.remesh(opts)\n</code></pre> <pre><code>from mmgpy import MmgSOptions, read\n\nmesh = read(\"surface.stl\")\n\nopts = MmgSOptions(\n    hmin=0.01,\n    hmax=0.1,\n    hausd=0.001,\n    verbose=1,\n)\n\nresult = mesh.remesh(opts)\n</code></pre>"},{"location":"getting-started/quickstart/#factory-presets","title":"Factory Presets","text":"<p>Options classes provide convenient factory methods for common use cases:</p> <pre><code>from mmgpy import Mmg3DOptions\n\n# Fine mesh (small elements)\nfine_opts = Mmg3DOptions.fine()\n\n# Coarse mesh (large elements)\ncoarse_opts = Mmg3DOptions.coarse()\n\n# Optimization only (no topology changes)\nopt_opts = Mmg3DOptions.optimize_only()\n</code></pre>"},{"location":"getting-started/quickstart/#local-sizing-control","title":"Local Sizing Control","text":"<p>Refine the mesh in specific regions:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Fine mesh in a spherical region\nmesh.set_size_sphere(\n    center=[0.5, 0.5, 0.5],\n    radius=0.2,\n    size=0.01,\n)\n\n# Fine mesh in a box region\nmesh.set_size_box(\n    bounds=[[0, 0, 0], [0.3, 0.3, 0.3]],\n    size=0.02,\n)\n\n# Remesh with global hmax, local sizing takes precedence\nresult = mesh.remesh(hmax=0.1, verbose=-1)\n</code></pre>"},{"location":"getting-started/quickstart/#pyvista-visualization","title":"PyVista Visualization","text":"<p>Visualize meshes with PyVista:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\n# Load and remesh\nmesh = mmgpy.read(\"input.mesh\")\nmesh.remesh(hmax=0.1)\n\n# Convert to PyVista and visualize\npv_mesh = mesh.to_pyvista()\npv_mesh.plot(show_edges=True)\n</code></pre> <p>Load from PyVista:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\n# Create a PyVista mesh\nsphere = pv.Sphere(radius=1.0)\n\n# Convert to mmgpy mesh\nmesh = mmgpy.from_pyvista(sphere, mesh_type=\"surface\")\n\n# Remesh and visualize\nmesh.remesh(hmax=0.1)\nmesh.to_pyvista().plot(show_edges=True)\n</code></pre>"},{"location":"getting-started/quickstart/#mesh-validation","title":"Mesh Validation","text":"<p>Check mesh quality before and after remeshing:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Quick validation (returns bool)\nif mesh.validate():\n    print(\"Mesh is valid\")\nelse:\n    print(\"Mesh has issues\")\n\n# Detailed validation report\nreport = mesh.validate(detailed=True)\nprint(f\"Valid: {report.is_valid}\")\nprint(f\"Mean quality: {report.quality.mean:.3f}\")\nprint(f\"Min quality: {report.quality.min:.3f}\")\n\nfor issue in report.issues:\n    print(f\"  {issue.severity}: {issue.message}\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Understand mesh types and remeshing strategies</li> <li>Basic Remeshing Tutorial - In-depth remeshing guide</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"reference/cli/","title":"CLI Tools","text":"<p>Installing mmgpy gives you access to the MMG command-line executables:</p> Command Description <code>mmg2d_O3</code> 2D remeshing <code>mmg3d_O3</code> 3D remeshing <code>mmgs_O3</code> Surface remeshing"},{"location":"reference/cli/#installation","title":"Installation","text":"<p>The executables are included with mmgpy:</p> <pre><code>pip install mmgpy\n</code></pre> <p>If you only need the CLI tools (no Python API):</p> <pre><code>uv tool install mmgpy\n</code></pre>"},{"location":"reference/cli/#quick-examples","title":"Quick Examples","text":"<pre><code>mmg3d_O3 input.mesh -o output.mesh -hmax 0.1\nmmgs_O3 surface.stl -o refined.mesh -hausd 0.001\nmmg2d_O3 domain.mesh -o refined.mesh -hmax 0.05\n</code></pre>"},{"location":"reference/cli/#documentation","title":"Documentation","text":"<p>For complete documentation on MMG command-line options, parameters, and usage, refer to the official MMG documentation:</p> <ul> <li>MMG Official Documentation</li> <li>MMG GitHub Wiki</li> <li>MMG Tutorials</li> </ul>"},{"location":"reference/cli/#troubleshooting","title":"Troubleshooting","text":"<p>On macOS and Linux, if the executables fail to find libraries:</p> <pre><code>fix-mmg-rpath\n</code></pre>"},{"location":"reference/file-formats/","title":"File Formats","text":"<p>mmgpy supports numerous file formats through its integration with meshio.</p>"},{"location":"reference/file-formats/#native-mmg-format","title":"Native MMG Format","text":"<p>The <code>.mesh</code> (ASCII) and <code>.meshb</code> (binary) formats are the native MMG formats and are recommended for best compatibility.</p>"},{"location":"reference/file-formats/#mesh-format-structure","title":".mesh Format Structure","text":"<pre><code>MeshVersionFormatted 2\nDimension 3\n\nVertices\n4\n0.0 0.0 0.0 0\n1.0 0.0 0.0 0\n0.0 1.0 0.0 0\n0.0 0.0 1.0 0\n\nTriangles\n4\n1 2 3 0\n1 2 4 0\n1 3 4 0\n2 3 4 0\n\nTetrahedra\n1\n1 2 3 4 0\n\nEnd\n</code></pre>"},{"location":"reference/file-formats/#supported-formats","title":"Supported Formats","text":""},{"location":"reference/file-formats/#volume-mesh-formats-3d","title":"Volume Mesh Formats (3D)","text":"Format Extensions Read Write Notes MMG <code>.mesh</code>, <code>.meshb</code> Yes Yes Native, recommended VTK Legacy <code>.vtk</code> Yes Yes Universal VTK XML <code>.vtu</code> Yes Yes Modern VTK GMSH <code>.msh</code> Yes Yes Popular for FEM Abaqus <code>.inp</code> Yes Yes FEM CGNS <code>.cgns</code> Yes Yes CFD Exodus II <code>.e</code>, <code>.exo</code> Yes Yes Sandia MED <code>.med</code> Yes Yes Salome NASTRAN <code>.bdf</code>, <code>.nas</code> Yes Limited FEM"},{"location":"reference/file-formats/#surface-mesh-formats","title":"Surface Mesh Formats","text":"Format Extensions Read Write Notes STL <code>.stl</code> Yes Yes CAD export OBJ <code>.obj</code> Yes Yes Graphics PLY <code>.ply</code> Yes Yes Point cloud/mesh OFF <code>.off</code> Yes Yes Simple format VTK <code>.vtp</code> Yes Yes VTK polygonal"},{"location":"reference/file-formats/#2d-mesh-formats","title":"2D Mesh Formats","text":"Format Extensions Read Write Notes MMG <code>.mesh</code> Yes Yes Native VTK <code>.vtk</code>, <code>.vtu</code> Yes Yes Universal SVG <code>.svg</code> No Yes Visualization"},{"location":"reference/file-formats/#format-selection-guide","title":"Format Selection Guide","text":""},{"location":"reference/file-formats/#for-mmg-processing","title":"For MMG Processing","text":"<p>Use <code>.mesh</code> format:</p> <pre><code>mesh.save(\"output.mesh\")\n</code></pre> <ul> <li>Best compatibility with MMG</li> <li>Supports all MMG-specific features</li> <li>Can include solution/metric files</li> </ul>"},{"location":"reference/file-formats/#for-visualization-paraview","title":"For Visualization (ParaView)","text":"<p>Use VTK formats:</p> <pre><code>mesh.save(\"output.vtk\")   # Legacy\nmesh.save(\"output.vtu\")   # XML (preferred)\n</code></pre>"},{"location":"reference/file-formats/#for-cad3d-printing","title":"For CAD/3D Printing","text":"<p>Use STL:</p> <pre><code># Surface meshes only\nmesh.save(\"output.stl\")\n</code></pre>"},{"location":"reference/file-formats/#for-other-software","title":"For Other Software","text":"Software Recommended Format ParaView <code>.vtu</code>, <code>.vtk</code> GMSH <code>.msh</code> Abaqus <code>.inp</code> Salome <code>.med</code> Blender <code>.obj</code>, <code>.stl</code>, <code>.ply</code> FreeCAD <code>.stl</code>, <code>.obj</code>"},{"location":"reference/file-formats/#solution-files","title":"Solution Files","text":"<p>MMG supports solution files (<code>.sol</code>) containing:</p> <ul> <li>Scalar fields (temperature, pressure)</li> <li>Vector fields (velocity, displacement)</li> <li>Tensor fields (stress, metric)</li> </ul>"},{"location":"reference/file-formats/#creating-solution-files","title":"Creating Solution Files","text":"<pre><code>import numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Add scalar field\ntemperature = np.random.rand(mesh.get_mesh_size()[\"vertices\"])\nmesh[\"temperature\"] = temperature\n\n# Save mesh and solution\nmesh.save(\"output.mesh\")  # Also saves output.sol if fields exist\n</code></pre>"},{"location":"reference/file-formats/#loading-solution-files","title":"Loading Solution Files","text":"<pre><code># Solution file is loaded automatically if present\nmesh = mmgpy.read(\"input.mesh\")\n\n# Access fields\nif \"temperature\" in mesh:\n    temp = mesh[\"temperature\"]\n</code></pre>"},{"location":"reference/file-formats/#binary-vs-ascii","title":"Binary vs ASCII","text":"Aspect ASCII (.mesh) Binary (.meshb) File size Larger Smaller Read speed Slower Faster Human readable Yes No Precision Text representation Full precision <pre><code># ASCII\nmesh.save(\"output.mesh\")\n\n# Binary\nmesh.save(\"output.meshb\")\n</code></pre>"},{"location":"reference/file-formats/#format-detection","title":"Format Detection","text":"<p>mmgpy automatically detects format from extension:</p> <pre><code># Auto-detected from extension\nmesh = mmgpy.read(\"model.stl\")\nmesh = mmgpy.read(\"simulation.vtu\")\nmesh = mmgpy.read(\"domain.msh\")\n</code></pre>"},{"location":"reference/file-formats/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/file-formats/#unsupported-format","title":"Unsupported Format","text":"<p>If a format is not recognized:</p> <ol> <li>Check the extension is correct</li> <li>Ensure meshio supports the format</li> <li>Try converting to <code>.mesh</code> or <code>.vtk</code> first</li> </ol>"},{"location":"reference/file-formats/#lost-data","title":"Lost Data","text":"<p>Some formats don't support all features:</p> Data Type .mesh .vtk .stl Vertices Yes Yes Yes Triangles Yes Yes Yes Tetrahedra Yes Yes No Scalar fields Via .sol Yes No Vector fields Via .sol Yes No Material IDs Yes Yes No"},{"location":"reference/file-formats/#large-files","title":"Large Files","text":"<p>For large meshes:</p> <pre><code># Use binary format\nmesh.save(\"large_mesh.meshb\")\n\n# Or compressed VTK\nmesh.save(\"large_mesh.vtu\")  # XML VTK supports compression\n</code></pre>"},{"location":"reference/mmg-parameters/","title":"MMG Parameters Reference","text":"<p>Complete reference for all MMG remeshing parameters.</p>"},{"location":"reference/mmg-parameters/#size-parameters","title":"Size Parameters","text":""},{"location":"reference/mmg-parameters/#hmin","title":"hmin","text":"<p>Minimum edge length.</p> Property Value Type <code>float</code> Default Auto-computed Range &gt; 0 <pre><code>result = mesh.remesh(hmin=0.01)\n</code></pre> <p>Edges shorter than <code>hmin</code> will be collapsed or lengthened.</p>"},{"location":"reference/mmg-parameters/#hmax","title":"hmax","text":"<p>Maximum edge length.</p> Property Value Type <code>float</code> Default Auto-computed Range &gt; hmin <pre><code>result = mesh.remesh(hmax=0.1)\n</code></pre> <p>Edges longer than <code>hmax</code> will be split.</p>"},{"location":"reference/mmg-parameters/#hsiz","title":"hsiz","text":"<p>Uniform target edge size.</p> Property Value Type <code>float</code> Default None Range &gt; 0 <pre><code>result = mesh.remesh(hsiz=0.05)\n</code></pre> <p>When set, overrides <code>hmin</code> and <code>hmax</code> with uniform sizing.</p>"},{"location":"reference/mmg-parameters/#hgrad","title":"hgrad","text":"<p>Gradation parameter controlling size transition.</p> Property Value Type <code>float</code> Default 1.3 Range &gt;= 1.0 <pre><code>result = mesh.remesh(hgrad=1.2)\n</code></pre> <ul> <li><code>hgrad=1.0</code>: No size variation allowed</li> <li><code>hgrad=1.3</code>: Default, allows 30% size change between adjacent edges</li> <li><code>hgrad=2.0</code>: Large size variations allowed</li> </ul>"},{"location":"reference/mmg-parameters/#geometric-parameters","title":"Geometric Parameters","text":""},{"location":"reference/mmg-parameters/#hausd","title":"hausd","text":"<p>Hausdorff distance - maximum distance between input and output geometry.</p> Property Value Type <code>float</code> Default 0.01 * bounding box diagonal Range &gt; 0 <pre><code>result = mesh.remesh(hausd=0.001)\n</code></pre> <p>Smaller values = better geometric approximation but more elements.</p>"},{"location":"reference/mmg-parameters/#angle","title":"angle","text":"<p>Ridge detection angle in degrees.</p> Property Value Type <code>float</code> Default 45.0 Range 0 - 180 <pre><code>result = mesh.remesh(angle=30.0)\n</code></pre> <ul> <li>Edges with dihedral angle &gt; <code>angle</code> are treated as ridges</li> <li>Ridges are preserved during remeshing</li> <li><code>angle=180</code>: No ridge detection</li> </ul>"},{"location":"reference/mmg-parameters/#control-flags","title":"Control Flags","text":""},{"location":"reference/mmg-parameters/#optim","title":"optim","text":"<p>Enable optimization mode.</p> Property Value Type <code>int</code> Default 0 Values 0 (off), 1 (on) <pre><code>result = mesh.remesh(optim=1)\n</code></pre> <p>When enabled, only moves vertices to improve quality (no topology changes).</p>"},{"location":"reference/mmg-parameters/#noinsert","title":"noinsert","text":"<p>Disable vertex insertion.</p> Property Value Type <code>int</code> Default 0 Values 0 (off), 1 (on) <pre><code>result = mesh.remesh(noinsert=1)\n</code></pre> <p>Prevents adding new vertices during remeshing.</p>"},{"location":"reference/mmg-parameters/#noswap","title":"noswap","text":"<p>Disable edge/face swapping.</p> Property Value Type <code>int</code> Default 0 Values 0 (off), 1 (on) <pre><code>result = mesh.remesh(noswap=1)\n</code></pre> <p>Prevents topology changes via edge/face swaps.</p>"},{"location":"reference/mmg-parameters/#nomove","title":"nomove","text":"<p>Disable vertex movement.</p> Property Value Type <code>int</code> Default 0 Values 0 (off), 1 (on) <pre><code>result = mesh.remesh(nomove=1)\n</code></pre> <p>Keeps vertices at their original positions.</p>"},{"location":"reference/mmg-parameters/#nosurf","title":"nosurf","text":"<p>Preserve surface vertices.</p> Property Value Type <code>int</code> Default 0 Values 0 (off), 1 (on) <pre><code>result = mesh.remesh(nosurf=1)\n</code></pre> <p>Prevents modification of surface mesh vertices.</p>"},{"location":"reference/mmg-parameters/#output-control","title":"Output Control","text":""},{"location":"reference/mmg-parameters/#verbose","title":"verbose","text":"<p>Verbosity level.</p> Property Value Type <code>int</code> Default 1 Range -1 to 10 <pre><code>result = mesh.remesh(verbose=-1)  # Silent\nresult = mesh.remesh(verbose=0)   # Errors only\nresult = mesh.remesh(verbose=1)   # Standard info\nresult = mesh.remesh(verbose=5)   # Debug output\n</code></pre>"},{"location":"reference/mmg-parameters/#common-combinations","title":"Common Combinations","text":""},{"location":"reference/mmg-parameters/#quality-optimization-only","title":"Quality Optimization Only","text":"<pre><code>result = mesh.remesh(optim=1, noinsert=1)\n</code></pre> <p>Or use the convenience method:</p> <pre><code>result = mesh.remesh_optimize()\n</code></pre>"},{"location":"reference/mmg-parameters/#uniform-remeshing","title":"Uniform Remeshing","text":"<pre><code>result = mesh.remesh(hsiz=0.05)\n</code></pre> <p>Or use the convenience method:</p> <pre><code>result = mesh.remesh_uniform(size=0.05)\n</code></pre>"},{"location":"reference/mmg-parameters/#high-quality-surface-approximation","title":"High-Quality Surface Approximation","text":"<pre><code>result = mesh.remesh(\n    hmax=0.1,\n    hausd=0.0001,  # Tight geometric tolerance\n    hgrad=1.1,     # Smooth size transition\n)\n</code></pre>"},{"location":"reference/mmg-parameters/#preserve-sharp-features","title":"Preserve Sharp Features","text":"<pre><code>result = mesh.remesh(\n    hmax=0.1,\n    angle=20.0,  # Detect more ridges\n    hausd=0.001,\n)\n</code></pre>"},{"location":"reference/mmg-parameters/#fast-coarse-remeshing","title":"Fast Coarse Remeshing","text":"<pre><code>result = mesh.remesh(\n    hmax=0.5,\n    hgrad=2.0,  # Allow large size variations\n    verbose=-1,\n)\n</code></pre>"},{"location":"reference/mmg-parameters/#volume-interior-only","title":"Volume Interior Only","text":"<pre><code>result = mesh.remesh(\n    hmax=0.1,\n    nosurf=1,  # Keep surface fixed\n)\n</code></pre>"},{"location":"reference/mmg-parameters/#parameter-interactions","title":"Parameter Interactions","text":"Parameters Effect <code>optim=1, noinsert=1</code> Quality optimization only <code>hmin=hmax</code> Near-uniform sizing <code>hausd</code> small + <code>hmax</code> large More elements on surface <code>angle=180</code> No ridge preservation <code>hgrad=1.0</code> No size gradation"},{"location":"reference/mmg-parameters/#best-practices","title":"Best Practices","text":"<ol> <li>Start with defaults: MMG auto-computes reasonable defaults</li> <li>Set <code>hmax</code> first: Most important parameter</li> <li>Add <code>hausd</code> for surfaces: Controls geometric fidelity</li> <li>Tune <code>hgrad</code>: Lower for smoother transitions</li> <li>Use <code>verbose=-1</code>: For batch processing</li> <li>Validate results: Always check mesh quality after remeshing</li> </ol>"},{"location":"tutorials/adaptive-sizing/","title":"Adaptive Sizing","text":"<p>This tutorial covers local mesh refinement using sizing constraints.</p>"},{"location":"tutorials/adaptive-sizing/#overview","title":"Overview","text":"<p>While global parameters like <code>hmax</code> apply to the entire mesh, adaptive sizing lets you refine specific regions. mmgpy supports several sizing constraints:</p> <ul> <li>Sphere: Refine within a spherical region</li> <li>Box: Refine within an axis-aligned box</li> <li>Cylinder: Refine within a cylindrical region (3D only)</li> <li>Point: Distance-based sizing from a reference point</li> </ul>"},{"location":"tutorials/adaptive-sizing/#spherical-refinement","title":"Spherical Refinement","text":"<p>Refine mesh within a sphere:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Add spherical refinement zone\nmesh.set_size_sphere(\n    center=[0.5, 0.5, 0.5],  # Sphere center\n    radius=0.2,              # Sphere radius\n    size=0.01,               # Target edge size inside sphere\n)\n\n# Remesh with global hmax (local sizing takes precedence where defined)\nresult = mesh.remesh(hmax=0.1, verbose=-1)\n</code></pre> <p>Multiple spheres can be combined:</p> <pre><code># Fine region near origin\nmesh.set_size_sphere(center=[0, 0, 0], radius=0.1, size=0.005)\n\n# Medium region elsewhere\nmesh.set_size_sphere(center=[1, 1, 1], radius=0.3, size=0.02)\n\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#box-refinement","title":"Box Refinement","text":"<p>Refine within an axis-aligned bounding box:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Add box refinement zone\nmesh.set_size_box(\n    bounds=[[0, 0, 0], [0.3, 0.3, 0.3]],  # [[xmin, ymin, zmin], [xmax, ymax, zmax]]\n    size=0.01,\n)\n\nresult = mesh.remesh(hmax=0.1)\n</code></pre> <p>For 2D meshes:</p> <pre><code>mesh.set_size_box(\n    bounds=[[0, 0], [0.5, 0.5]],  # [[xmin, ymin], [xmax, ymax]]\n    size=0.01,\n)\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#cylindrical-refinement","title":"Cylindrical Refinement","text":"<p>Refine within a cylindrical region (3D meshes only):</p> <pre><code>import mmgpy\n\nmesh = mmgpy.MmgMesh3D(\"input.mesh\")\n\n# Cylinder along x-axis\nmesh.set_size_cylinder(\n    point1=[0, 0.5, 0.5],    # First endpoint of axis\n    point2=[1, 0.5, 0.5],    # Second endpoint of axis\n    radius=0.1,              # Cylinder radius\n    size=0.01,               # Target edge size\n)\n\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#distance-based-sizing","title":"Distance-Based Sizing","text":"<p>Create graded mesh with size varying by distance from a point:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Size varies from 0.01 at the point to 0.1 at influence_radius\nmesh.set_size_from_point(\n    point=[0.5, 0.5, 0.5],\n    near_size=0.01,          # Size at the reference point\n    far_size=0.1,            # Size at and beyond influence_radius\n    influence_radius=0.5,    # Distance over which size transitions\n)\n\nresult = mesh.remesh()\n</code></pre> <p>This creates a smooth gradation from fine to coarse mesh.</p>"},{"location":"tutorials/adaptive-sizing/#combining-constraints","title":"Combining Constraints","text":"<p>Multiple sizing constraints can be combined. Where they overlap, the minimum size wins:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Fine refinement in a small sphere\nmesh.set_size_sphere(center=[0.5, 0.5, 0.5], radius=0.1, size=0.005)\n\n# Medium refinement in a larger box\nmesh.set_size_box(bounds=[[0.3, 0.3, 0.3], [0.7, 0.7, 0.7]], size=0.02)\n\n# Gradient from a corner\nmesh.set_size_from_point(\n    point=[0, 0, 0],\n    near_size=0.01,\n    far_size=0.1,\n    influence_radius=0.5,\n)\n\n# Apply with global hmax\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#managing-constraints","title":"Managing Constraints","text":"<p>Check and clear sizing constraints:</p> <pre><code># Check number of active constraints\nn_constraints = mesh.get_local_sizing_count()\nprint(f\"Active constraints: {n_constraints}\")\n\n# Clear all constraints\nmesh.clear_local_sizing()\n\n# Verify cleared\nassert mesh.get_local_sizing_count() == 0\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#manual-application","title":"Manual Application","text":"<p>Sizing constraints are automatically applied before remeshing. You can also apply them manually to inspect the resulting metric field:</p> <pre><code># Add constraints\nmesh.set_size_sphere(center=[0.5, 0.5, 0.5], radius=0.2, size=0.01)\n\n# Apply constraints to metric field (without remeshing)\nmesh.apply_local_sizing()\n\n# Inspect the metric field\nmetric = mesh[\"metric\"]\nprint(f\"Metric field shape: {metric.shape}\")\n\n# Now remesh uses the pre-computed metric\nresult = mesh.remesh()\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#complete-example-cfd-boundary-layer","title":"Complete Example: CFD Boundary Layer","text":"<p>Create refined mesh near a surface for CFD simulations:</p> <pre><code>import mmgpy\nimport numpy as np\n\n# Load a 3D domain mesh\nmesh = mmgpy.read(\"domain.mesh\")\n\n# Fine mesh near inlet (box region)\nmesh.set_size_box(\n    bounds=[[-0.1, -0.1, -0.1], [0.1, 1.1, 1.1]],\n    size=0.005,\n)\n\n# Medium refinement near cylinder (boundary layer)\nmesh.set_size_cylinder(\n    point1=[0.5, 0.5, 0],\n    point2=[0.5, 0.5, 1],\n    radius=0.2,\n    size=0.01,\n)\n\n# Fine mesh at critical points\nfor point in [[0.5, 0.5, 0], [0.5, 0.5, 1]]:\n    mesh.set_size_sphere(center=point, radius=0.1, size=0.003)\n\n# Remesh with gradual size transition\nresult = mesh.remesh(hmax=0.05, hgrad=1.2, verbose=1)\n\nprint(f\"Elements: {result.elements_before} -&gt; {result.elements_after}\")\nmesh.save(\"refined_domain.vtk\")\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#using-sizing-constraint-classes-directly","title":"Using Sizing Constraint Classes Directly","text":"<p>For programmatic use, you can use the sizing constraint classes directly:</p> <pre><code>from mmgpy import SphereSize, BoxSize, CylinderSize, PointSize\nfrom mmgpy.sizing import apply_sizing_constraints\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Create constraint objects\nconstraints = [\n    SphereSize(\n        center=np.array([0.5, 0.5, 0.5]),\n        radius=0.2,\n        size=0.01,\n    ),\n    BoxSize(\n        bounds=np.array([[0, 0, 0], [0.3, 0.3, 0.3]]),\n        size=0.02,\n    ),\n]\n\n# Apply directly\napply_sizing_constraints(mesh, constraints)\n\nresult = mesh.remesh(hmax=0.1)\n</code></pre>"},{"location":"tutorials/adaptive-sizing/#next-steps","title":"Next Steps","text":"<ul> <li>PyVista Integration - Visualize adaptive meshes</li> <li>Metrics - Advanced anisotropic sizing</li> </ul>"},{"location":"tutorials/basic-remeshing/","title":"Basic Remeshing","text":"<p>This tutorial covers the fundamentals of mesh remeshing with mmgpy.</p>"},{"location":"tutorials/basic-remeshing/#loading-a-mesh","title":"Loading a Mesh","text":"<p>mmgpy can load meshes from 40+ file formats:</p> <pre><code>import mmgpy\n\n# Using the unified read function (recommended)\nmesh = mmgpy.read(\"input.mesh\")\n\n# Or use specific mesh classes directly\nmesh_3d = mmgpy.MmgMesh3D(\"volume.mesh\")\nmesh_2d = mmgpy.MmgMesh2D(\"planar.mesh\")\nmesh_s = mmgpy.MmgMeshS(\"surface.stl\")\n</code></pre> <p>The <code>read()</code> function automatically detects the mesh type and returns the appropriate class wrapped in a unified <code>Mesh</code> interface.</p>"},{"location":"tutorials/basic-remeshing/#simple-remeshing","title":"Simple Remeshing","text":"<p>The simplest remeshing operation specifies only the maximum edge length:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Remesh with maximum edge length of 0.1\nresult = mesh.remesh(hmax=0.1)\n\nprint(f\"Vertices: {result.vertices_before} -&gt; {result.vertices_after}\")\nprint(f\"Elements: {result.elements_before} -&gt; {result.elements_after}\")\n</code></pre>"},{"location":"tutorials/basic-remeshing/#understanding-remeshresult","title":"Understanding RemeshResult","text":"<p>Every remeshing operation returns a <code>RemeshResult</code> object with statistics:</p> <pre><code>result = mesh.remesh(hmax=0.1)\n\n# Vertex counts\nprint(f\"Vertices before: {result.vertices_before}\")\nprint(f\"Vertices after: {result.vertices_after}\")\n\n# Element counts\nprint(f\"Elements before: {result.elements_before}\")\nprint(f\"Elements after: {result.elements_after}\")\n\n# Quality metrics\nprint(f\"Min quality before: {result.quality_min_before:.3f}\")\nprint(f\"Min quality after: {result.quality_min_after:.3f}\")\nprint(f\"Mean quality before: {result.quality_mean_before:.3f}\")\nprint(f\"Mean quality after: {result.quality_mean_after:.3f}\")\n\n# Timing\nprint(f\"Duration: {result.duration_seconds:.2f} seconds\")\n\n# Warnings from MMG\nfor warning in result.warnings:\n    print(f\"Warning: {warning}\")\n</code></pre>"},{"location":"tutorials/basic-remeshing/#edge-length-control","title":"Edge Length Control","text":"<p>Control the range of edge lengths in the output mesh:</p> <pre><code>result = mesh.remesh(\n    hmin=0.01,  # Minimum edge length (prevents over-refinement)\n    hmax=0.1,   # Maximum edge length\n)\n</code></pre> <p>For a uniform mesh with a single target size:</p> <pre><code># Using hsiz parameter\nresult = mesh.remesh(hsiz=0.05)\n\n# Or using the convenience method\nresult = mesh.remesh_uniform(size=0.05)\n</code></pre>"},{"location":"tutorials/basic-remeshing/#geometric-approximation","title":"Geometric Approximation","text":"<p>The <code>hausd</code> parameter controls how closely the output mesh approximates the input geometry:</p> <pre><code>result = mesh.remesh(\n    hmax=0.1,\n    hausd=0.001,  # Maximum Hausdorff distance to input surface\n)\n</code></pre> <p>!!! tip \"Choosing hausd\" - Smaller <code>hausd</code> = better surface approximation but more elements - Typical values: 0.001 to 0.01 of the model size - For smooth surfaces, use smaller values</p>"},{"location":"tutorials/basic-remeshing/#using-options-objects","title":"Using Options Objects","text":"<p>For complex configurations, use typed options objects:</p> <pre><code>from mmgpy import Mmg3DOptions\n\n# Create options with all parameters\nopts = Mmg3DOptions(\n    hmin=0.01,\n    hmax=0.1,\n    hausd=0.001,\n    hgrad=1.3,      # Gradation: max ratio between adjacent edges\n    angle=45.0,     # Ridge detection angle (degrees)\n    verbose=1,\n)\n\nresult = mesh.remesh(opts)\n</code></pre> <p>Options can be unpacked directly into <code>remesh()</code>:</p> <pre><code>result = mesh.remesh(**opts.to_dict())\n</code></pre>"},{"location":"tutorials/basic-remeshing/#optimization-without-topology-changes","title":"Optimization Without Topology Changes","text":"<p>To improve quality without inserting/removing vertices:</p> <pre><code># Using the convenience method\nresult = mesh.remesh_optimize()\n\n# Equivalent to\nresult = mesh.remesh(optim=1, noinsert=1)\n</code></pre> <p>This only moves existing vertices to improve element quality.</p>"},{"location":"tutorials/basic-remeshing/#factory-presets","title":"Factory Presets","text":"<p>Options classes provide factory methods for common scenarios:</p> <pre><code>from mmgpy import Mmg3DOptions\n\n# Fine mesh preset\nfine_opts = Mmg3DOptions.fine()\nresult = mesh.remesh(fine_opts)\n\n# Coarse mesh preset\ncoarse_opts = Mmg3DOptions.coarse()\nresult = mesh.remesh(coarse_opts)\n\n# Optimization-only preset\nopt_opts = Mmg3DOptions.optimize_only()\nresult = mesh.remesh(opt_opts)\n</code></pre>"},{"location":"tutorials/basic-remeshing/#saving-results","title":"Saving Results","text":"<p>Save the remeshed output to any supported format:</p> <pre><code># Save to MMG native format\nmesh.save(\"output.mesh\")\n\n# Save to VTK for ParaView\nmesh.save(\"output.vtk\")\n\n# Save to other formats\nmesh.save(\"output.stl\")  # Surface only\nmesh.save(\"output.ply\")\n</code></pre>"},{"location":"tutorials/basic-remeshing/#complete-example","title":"Complete Example","text":"<pre><code>import mmgpy\nfrom mmgpy import Mmg3DOptions\n\n# Load mesh\nmesh = mmgpy.read(\"input.mesh\")\n\n# Check initial quality\nreport = mesh.validate(detailed=True)\nprint(f\"Initial quality: {report.quality.mean:.3f}\")\n\n# Create options\nopts = Mmg3DOptions(\n    hmin=0.01,\n    hmax=0.1,\n    hausd=0.001,\n    verbose=1,\n)\n\n# Remesh\nresult = mesh.remesh(opts)\n\n# Report results\nprint(f\"\\nRemeshing complete in {result.duration_seconds:.2f}s\")\nprint(f\"Vertices: {result.vertices_before} -&gt; {result.vertices_after}\")\nprint(f\"Quality: {result.quality_mean_before:.3f} -&gt; {result.quality_mean_after:.3f}\")\n\n# Validate final mesh\nassert mesh.validate(), \"Mesh validation failed\"\n\n# Save result\nmesh.save(\"output.vtk\")\n</code></pre>"},{"location":"tutorials/basic-remeshing/#next-steps","title":"Next Steps","text":"<ul> <li>Surface Remeshing - Working with surface meshes</li> <li>Adaptive Sizing - Local mesh refinement</li> <li>PyVista Integration - Visualization workflows</li> </ul>"},{"location":"tutorials/levelset-extraction/","title":"Level-Set Extraction","text":"<p>This tutorial covers extracting and remeshing isosurfaces using level-set functions.</p>"},{"location":"tutorials/levelset-extraction/#overview","title":"Overview","text":"<p>Level-set remeshing extracts an isosurface from a scalar field defined on a mesh. This is useful for:</p> <ul> <li>Extracting surfaces from signed distance functions</li> <li>Generating meshes from implicit functions</li> <li>Multi-material interface meshing</li> <li>Shape optimization</li> </ul>"},{"location":"tutorials/levelset-extraction/#basic-level-set-remeshing","title":"Basic Level-Set Remeshing","text":"<p>Define a level-set function and extract the zero isosurface:</p> <pre><code>import mmgpy\nimport numpy as np\n\n# Load or create a background mesh\nmesh = mmgpy.MmgMesh3D(\"background.mesh\")\n\n# Get vertex coordinates\nvertices = mesh.get_vertices()\n\n# Define level-set: signed distance to a sphere\ncenter = np.array([0.5, 0.5, 0.5])\nradius = 0.3\nlevelset = np.linalg.norm(vertices - center, axis=1) - radius\n\n# Remesh with level-set discretization\nresult = mesh.remesh_levelset(levelset)\n\nprint(f\"Extracted surface with {result.triangles_after} triangles\")\n</code></pre>"},{"location":"tutorials/levelset-extraction/#creating-background-meshes","title":"Creating Background Meshes","text":"<p>The background mesh should encompass the region where the level-set is defined:</p> <pre><code>import mmgpy\nimport numpy as np\n\n# Create a simple cubic mesh\n# (In practice, load from file or create with another tool)\n\n# For a unit cube background\nn = 10  # Resolution per edge\nx = np.linspace(0, 1, n)\ny = np.linspace(0, 1, n)\nz = np.linspace(0, 1, n)\n\n# Create tetrahedral mesh from grid\n# (Simplified - real implementation would need proper tetrahedralization)\nmesh = mmgpy.MmgMesh3D(\"unit_cube.mesh\")\n</code></pre>"},{"location":"tutorials/levelset-extraction/#implicit-function-examples","title":"Implicit Function Examples","text":""},{"location":"tutorials/levelset-extraction/#sphere","title":"Sphere","text":"<pre><code>def sphere_levelset(coords, center=(0.5, 0.5, 0.5), radius=0.3):\n    return np.linalg.norm(coords - np.array(center), axis=1) - radius\n\nlevelset = sphere_levelset(mesh.get_vertices())\n</code></pre>"},{"location":"tutorials/levelset-extraction/#torus","title":"Torus","text":"<pre><code>def torus_levelset(coords, R=0.5, r=0.15):\n    x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]\n    # Translate to center at (0.5, 0.5, 0.5)\n    x, y, z = x - 0.5, y - 0.5, z - 0.5\n    q = np.sqrt(x**2 + y**2) - R\n    return np.sqrt(q**2 + z**2) - r\n\nlevelset = torus_levelset(mesh.get_vertices())\n</code></pre>"},{"location":"tutorials/levelset-extraction/#gyroid","title":"Gyroid","text":"<pre><code>def gyroid_levelset(coords, scale=2*np.pi):\n    x = coords[:, 0] * scale\n    y = coords[:, 1] * scale\n    z = coords[:, 2] * scale\n    return np.sin(x)*np.cos(y) + np.sin(y)*np.cos(z) + np.sin(z)*np.cos(x)\n\nlevelset = gyroid_levelset(mesh.get_vertices())\n</code></pre>"},{"location":"tutorials/levelset-extraction/#boolean-operations","title":"Boolean Operations","text":"<p>Combine shapes using min/max operations:</p> <pre><code># Union: min of level-sets\ndef union(ls1, ls2):\n    return np.minimum(ls1, ls2)\n\n# Intersection: max of level-sets\ndef intersection(ls1, ls2):\n    return np.maximum(ls1, ls2)\n\n# Subtraction: max of ls1 and negated ls2\ndef subtract(ls1, ls2):\n    return np.maximum(ls1, -ls2)\n\n# Example: sphere with cylindrical hole\nsphere = sphere_levelset(vertices, center=(0.5, 0.5, 0.5), radius=0.4)\ncylinder = cylinder_levelset(vertices)  # Define appropriately\n\nresult_ls = subtract(sphere, cylinder)\n</code></pre>"},{"location":"tutorials/levelset-extraction/#2d-level-set-remeshing","title":"2D Level-Set Remeshing","text":"<p>Level-set extraction also works with 2D meshes:</p> <pre><code>import mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMesh2D(\"background_2d.mesh\")\nvertices = mesh.get_vertices()\n\n# Circle level-set\ncenter = np.array([0.5, 0.5])\nradius = 0.3\nlevelset = np.linalg.norm(vertices[:, :2] - center, axis=1) - radius\n\nresult = mesh.remesh_levelset(levelset)\n</code></pre>"},{"location":"tutorials/levelset-extraction/#surface-level-set-remeshing","title":"Surface Level-Set Remeshing","text":"<p>For surface meshes, level-set can extract curves:</p> <pre><code>import mmgpy\nimport numpy as np\n\nmesh = mmgpy.MmgMeshS(\"surface.mesh\")\nvertices = mesh.get_vertices()\n\n# Level-set based on z-coordinate (extracts z=0 curve)\nlevelset = vertices[:, 2]\n\nresult = mesh.remesh_levelset(levelset)\n</code></pre>"},{"location":"tutorials/levelset-extraction/#controlling-output-quality","title":"Controlling Output Quality","text":"<p>Combine level-set extraction with size parameters:</p> <pre><code>result = mesh.remesh_levelset(\n    levelset,\n    hmin=0.005,\n    hmax=0.05,\n    hausd=0.0001,  # Tight approximation\n    verbose=1,\n)\n</code></pre>"},{"location":"tutorials/levelset-extraction/#complete-example-implicit-domain-meshing","title":"Complete Example: Implicit Domain Meshing","text":"<pre><code>import mmgpy\nimport numpy as np\n\n# Load background mesh\nmesh = mmgpy.MmgMesh3D(\"domain.mesh\")\nvertices = mesh.get_vertices()\n\n# Define a complex implicit function: two intersecting spheres\ndef double_sphere(coords):\n    center1 = np.array([0.35, 0.5, 0.5])\n    center2 = np.array([0.65, 0.5, 0.5])\n    radius = 0.25\n\n    d1 = np.linalg.norm(coords - center1, axis=1) - radius\n    d2 = np.linalg.norm(coords - center2, axis=1) - radius\n\n    return np.minimum(d1, d2)  # Union\n\nlevelset = double_sphere(vertices)\n\n# Extract the isosurface\nresult = mesh.remesh_levelset(\n    levelset,\n    hmax=0.03,\n    hausd=0.001,\n    verbose=1,\n)\n\nprint(f\"Extracted {result.triangles_after} triangles\")\nprint(f\"Quality: {result.quality_mean_after:.3f}\")\n\n# Save result\nmesh.save(\"double_sphere.vtk\")\n</code></pre>"},{"location":"tutorials/levelset-extraction/#visualization","title":"Visualization","text":"<pre><code>import pyvista as pv\n\n# Visualize the extracted surface\npv_mesh = mesh.to_pyvista()\npv_mesh.plot(show_edges=True)\n</code></pre>"},{"location":"tutorials/levelset-extraction/#tips","title":"Tips","text":"<ol> <li> <p>Background mesh quality: Use a sufficiently fine background mesh for accurate level-set discretization</p> </li> <li> <p>Signed distance: For best results, use signed distance functions (negative inside, positive outside)</p> </li> <li> <p>Narrow band: If your level-set is only valid near the surface, ensure the background mesh is refined in that region</p> </li> <li> <p>Validation: After extraction, validate the mesh to ensure quality:</p> </li> </ol> <pre><code>assert mesh.validate(), \"Extracted mesh has quality issues\"\n</code></pre> <ol> <li>Multiple materials: For multi-material interfaces, use multiple level-set operations</li> </ol>"},{"location":"tutorials/levelset-extraction/#next-steps","title":"Next Steps","text":"<ul> <li>Metrics - Anisotropic metric fields</li> <li>Lagrangian Motion - Moving mesh remeshing</li> </ul>"},{"location":"tutorials/pyvista-integration/","title":"PyVista Integration","text":"<p>This tutorial covers the integration between mmgpy and PyVista for visualization and mesh interoperability.</p>"},{"location":"tutorials/pyvista-integration/#overview","title":"Overview","text":"<p>PyVista is a powerful 3D visualization library for Python. mmgpy provides seamless conversion to and from PyVista meshes, enabling:</p> <ul> <li>Interactive visualization of meshes</li> <li>Loading meshes from PyVista geometric primitives</li> <li>Quality inspection and comparison</li> <li>Integration with PyVista workflows</li> </ul>"},{"location":"tutorials/pyvista-integration/#converting-to-pyvista","title":"Converting to PyVista","text":"<p>Convert any mmgpy mesh to PyVista:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\n# Load and remesh\nmesh = mmgpy.read(\"input.mesh\")\nmesh.remesh(hmax=0.1)\n\n# Convert to PyVista\npv_mesh = mesh.to_pyvista()\n\n# Visualize\npv_mesh.plot(show_edges=True)\n</code></pre>"},{"location":"tutorials/pyvista-integration/#converting-from-pyvista","title":"Converting from PyVista","text":"<p>Create mmgpy meshes from PyVista geometry:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\n# Create PyVista geometry\nsphere = pv.Sphere(radius=1.0)\n\n# Convert to surface mesh\nmesh = mmgpy.from_pyvista(sphere, mesh_type=\"surface\")\n\n# Or for volumetric meshes (requires tetrahedral cells)\ncube = pv.Box().triangulate().delaunay_3d()\nmesh_3d = mmgpy.from_pyvista(cube, mesh_type=\"3d\")\n</code></pre> <p>Mesh type options:</p> <code>mesh_type</code> Description <code>\"surface\"</code> Surface triangular mesh (<code>MmgMeshS</code>) <code>\"3d\"</code> Volumetric tetrahedral mesh (<code>MmgMesh3D</code>) <code>\"2d\"</code> 2D triangular mesh (<code>MmgMesh2D</code>)"},{"location":"tutorials/pyvista-integration/#visualization-examples","title":"Visualization Examples","text":""},{"location":"tutorials/pyvista-integration/#basic-visualization","title":"Basic Visualization","text":"<pre><code>import mmgpy\n\nmesh = mmgpy.read(\"input.mesh\")\nmesh.to_pyvista().plot(show_edges=True)\n</code></pre>"},{"location":"tutorials/pyvista-integration/#side-by-side-comparison","title":"Side-by-Side Comparison","text":"<p>Compare before and after remeshing:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\nmesh = mmgpy.read(\"input.mesh\")\nbefore = mesh.to_pyvista()\n\nmesh.remesh(hmax=0.1)\nafter = mesh.to_pyvista()\n\npl = pv.Plotter(shape=(1, 2))\n\npl.subplot(0, 0)\npl.add_mesh(before, show_edges=True, color=\"lightblue\")\npl.add_text(\"Before\", font_size=12)\n\npl.subplot(0, 1)\npl.add_mesh(after, show_edges=True, color=\"lightgreen\")\npl.add_text(\"After\", font_size=12)\n\npl.link_views()\npl.show()\n</code></pre>"},{"location":"tutorials/pyvista-integration/#quality-visualization","title":"Quality Visualization","text":"<p>Visualize element quality:</p> <pre><code>import mmgpy\nimport pyvista as pv\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\nmesh.remesh(hmax=0.1)\n\npv_mesh = mesh.to_pyvista()\n\n# Compute quality (PyVista has built-in quality metrics)\nquality = pv_mesh.compute_cell_quality(quality_measure=\"scaled_jacobian\")\n\n# Plot with quality colormap\nquality.plot(\n    scalars=\"CellQuality\",\n    cmap=\"RdYlGn\",\n    show_edges=True,\n    scalar_bar_args={\"title\": \"Quality\"},\n)\n</code></pre>"},{"location":"tutorials/pyvista-integration/#animation","title":"Animation","text":"<p>Animate a remeshing sequence:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\nmesh = mmgpy.read(\"input.mesh\")\n\npl = pv.Plotter()\nactor = pl.add_mesh(mesh.to_pyvista(), show_edges=True)\npl.show(interactive_update=True, auto_close=False)\n\nfor hmax in [0.5, 0.3, 0.2, 0.15, 0.1]:\n    mesh.remesh(hmax=hmax, verbose=-1)\n    actor.mapper.SetInputData(mesh.to_pyvista())\n    pl.update()\n\npl.close()\n</code></pre>"},{"location":"tutorials/pyvista-integration/#working-with-mesh-data","title":"Working with Mesh Data","text":""},{"location":"tutorials/pyvista-integration/#transferring-scalar-fields","title":"Transferring Scalar Fields","text":"<pre><code>import mmgpy\nimport pyvista as pv\nimport numpy as np\n\nmesh = mmgpy.read(\"input.mesh\")\n\n# Add a scalar field to the mesh\nvertices = mesh.get_vertices()\nscalar_field = np.sin(vertices[:, 0] * 2 * np.pi)\nmesh[\"temperature\"] = scalar_field\n\n# Convert to PyVista - fields are preserved\npv_mesh = mesh.to_pyvista()\n\n# Plot with scalar field\npv_mesh.plot(scalars=\"temperature\", show_edges=True, cmap=\"coolwarm\")\n</code></pre>"},{"location":"tutorials/pyvista-integration/#from-pyvista-with-data","title":"From PyVista with Data","text":"<pre><code>import mmgpy\nimport pyvista as pv\nimport numpy as np\n\n# Create PyVista mesh with data\nsphere = pv.Sphere()\nsphere[\"elevation\"] = sphere.points[:, 2]\n\n# Convert to mmgpy\nmesh = mmgpy.from_pyvista(sphere, mesh_type=\"surface\")\n\n# Access the field\nelevation = mesh[\"elevation\"]\nprint(f\"Elevation range: {elevation.min():.2f} to {elevation.max():.2f}\")\n</code></pre>"},{"location":"tutorials/pyvista-integration/#interactive-workflows","title":"Interactive Workflows","text":""},{"location":"tutorials/pyvista-integration/#interactive-refinement","title":"Interactive Refinement","text":"<pre><code>import mmgpy\nimport pyvista as pv\nfrom pyvista import examples\n\n# Load example mesh\nbunny = examples.download_bunny()\n\n# Convert to mmgpy surface mesh\nmesh = mmgpy.from_pyvista(bunny, mesh_type=\"surface\")\n\ndef remesh_callback(value):\n    mesh.remesh(hmax=value, verbose=-1)\n    pl.update()\n\npl = pv.Plotter()\nactor = pl.add_mesh(mesh.to_pyvista(), show_edges=True)\npl.add_slider_widget(\n    remesh_callback,\n    rng=[0.01, 0.1],\n    value=0.05,\n    title=\"hmax\",\n)\npl.show()\n</code></pre>"},{"location":"tutorials/pyvista-integration/#picking-points-for-refinement","title":"Picking Points for Refinement","text":"<pre><code>import mmgpy\nimport pyvista as pv\n\nmesh = mmgpy.read(\"input.mesh\")\npv_mesh = mesh.to_pyvista()\n\ndef add_refinement(point):\n    mesh.set_size_sphere(center=point, radius=0.1, size=0.01)\n    mesh.remesh(hmax=0.1, verbose=-1)\n    actor.mapper.SetInputData(mesh.to_pyvista())\n    pl.update()\n\npl = pv.Plotter()\nactor = pl.add_mesh(pv_mesh, show_edges=True, pickable=True)\npl.enable_point_picking(callback=add_refinement, show_message=\"Click to add refinement\")\npl.show()\n</code></pre>"},{"location":"tutorials/pyvista-integration/#complete-example","title":"Complete Example","text":"<p>Full workflow from PyVista primitive to remeshed output:</p> <pre><code>import mmgpy\nimport pyvista as pv\nimport numpy as np\n\n# Create a complex geometry in PyVista\ntorus = pv.ParametricTorus(ringradius=1.0, crosssectionradius=0.3)\n\n# Convert to mmgpy surface mesh\nmesh = mmgpy.from_pyvista(torus, mesh_type=\"surface\")\n\nprint(f\"Original: {mesh.get_mesh_size()['triangles']} triangles\")\n\n# Remesh with adaptive sizing\nmesh.set_size_sphere(center=[1.0, 0, 0], radius=0.3, size=0.02)\nresult = mesh.remesh(hmax=0.1, hausd=0.001, verbose=1)\n\nprint(f\"Remeshed: {result.triangles_after} triangles\")\nprint(f\"Quality: {result.quality_mean_after:.3f}\")\n\n# Visualize result\npv_result = mesh.to_pyvista()\n\npl = pv.Plotter()\npl.add_mesh(pv_result, show_edges=True, edge_color=\"gray\")\npl.add_text(f\"Quality: {result.quality_mean_after:.3f}\", font_size=10)\npl.show()\n</code></pre>"},{"location":"tutorials/pyvista-integration/#tips","title":"Tips","text":"<ol> <li> <p>Memory: Large meshes may use significant memory when converted. Consider saving to file for very large meshes.</p> </li> <li> <p>Cell types: PyVista supports many cell types, but mmgpy requires triangles (surface/2D) or tetrahedra (3D). Use <code>triangulate()</code> if needed.</p> </li> <li> <p>Coordinates: mmgpy uses 0-indexed arrays. PyVista point/cell IDs match directly.</p> </li> <li> <p>Performance: For real-time visualization, use <code>interactive_update=True</code> and batch updates.</p> </li> </ol>"},{"location":"tutorials/pyvista-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Level-Set Extraction - Extract isosurfaces</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"tutorials/surface-remeshing/","title":"Surface Remeshing","text":"<p>This tutorial covers remeshing 3D surface meshes with mmgpy.</p>"},{"location":"tutorials/surface-remeshing/#loading-surface-meshes","title":"Loading Surface Meshes","text":"<p>Surface meshes can be loaded from various formats:</p> <pre><code>import mmgpy\n\n# From STL (common CAD export format)\nmesh = mmgpy.read(\"model.stl\")\n\n# From OBJ\nmesh = mmgpy.read(\"model.obj\")\n\n# From MMG native format\nmesh = mmgpy.MmgMeshS(\"surface.mesh\")\n</code></pre>"},{"location":"tutorials/surface-remeshing/#basic-surface-remeshing","title":"Basic Surface Remeshing","text":"<p>Remesh a surface with target edge lengths:</p> <pre><code>import mmgpy\n\nmesh = mmgpy.read(\"surface.stl\")\n\nresult = mesh.remesh(\n    hmin=0.01,    # Minimum edge length\n    hmax=0.1,     # Maximum edge length\n    verbose=1,\n)\n\nprint(f\"Triangles: {result.triangles_before} -&gt; {result.triangles_after}\")\n</code></pre>"},{"location":"tutorials/surface-remeshing/#geometric-fidelity","title":"Geometric Fidelity","text":"<p>The <code>hausd</code> parameter is crucial for surface meshes - it controls how closely the remeshed surface approximates the original:</p> <pre><code># Tight approximation (more triangles, better geometry)\nresult = mesh.remesh(hmax=0.1, hausd=0.0001)\n\n# Looser approximation (fewer triangles)\nresult = mesh.remesh(hmax=0.1, hausd=0.01)\n</code></pre> <p>Hausdorff Distance</p> <p>Setting <code>hausd</code> too large can cause loss of geometric features. Start with small values (0.001) and increase if needed.</p>"},{"location":"tutorials/surface-remeshing/#sharp-feature-detection","title":"Sharp Feature Detection","text":"<p>MMG can detect and preserve sharp edges based on the angle between adjacent faces:</p> <pre><code>result = mesh.remesh(\n    hmax=0.1,\n    hausd=0.001,\n    angle=45.0,  # Edges sharper than 45\u00b0 are preserved as ridges\n)\n</code></pre>"},{"location":"tutorials/surface-remeshing/#preserving-boundaries","title":"Preserving Boundaries","text":"<p>To keep boundary edges fixed during remeshing:</p> <pre><code>result = mesh.remesh(\n    hmax=0.1,\n    nosurf=1,  # Preserve surface points\n)\n</code></pre>"},{"location":"tutorials/surface-remeshing/#smooth-surface-remeshing","title":"Smooth Surface Remeshing","text":"<p>For smooth surfaces without sharp features:</p> <pre><code>from mmgpy import MmgSOptions\n\nopts = MmgSOptions(\n    hmax=0.1,\n    hausd=0.0001,  # Tight approximation\n    hgrad=1.1,     # Gentle size gradation\n    angle=180.0,   # No ridge detection\n)\n\nresult = mesh.remesh(opts)\n</code></pre>"},{"location":"tutorials/surface-remeshing/#mechanical-part-remeshing","title":"Mechanical Part Remeshing","text":"<p>For industrial/CAD parts with sharp edges:</p> <pre><code>from mmgpy import MmgSOptions\n\nopts = MmgSOptions(\n    hmax=0.1,\n    hausd=0.001,\n    hgrad=1.3,\n    angle=30.0,    # Detect sharp edges\n)\n\nresult = mesh.remesh(opts)\n</code></pre>"},{"location":"tutorials/surface-remeshing/#converting-from-pyvista","title":"Converting from PyVista","text":"<p>Create surface meshes from PyVista geometry:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\n# Create a PyVista surface\nsphere = pv.Sphere(radius=1.0, theta_resolution=20, phi_resolution=20)\n\n# Convert to mmgpy surface mesh\nmesh = mmgpy.from_pyvista(sphere, mesh_type=\"surface\")\n\n# Remesh\nmesh.remesh(hmax=0.1)\n\n# Visualize\nmesh.to_pyvista().plot(show_edges=True)\n</code></pre>"},{"location":"tutorials/surface-remeshing/#visualization","title":"Visualization","text":"<p>Visualize before and after:</p> <pre><code>import mmgpy\nimport pyvista as pv\n\n# Load and convert to PyVista\nmesh = mmgpy.read(\"surface.stl\")\nbefore = mesh.to_pyvista()\n\n# Remesh\nmesh.remesh(hmax=0.1, hausd=0.001)\nafter = mesh.to_pyvista()\n\n# Side-by-side comparison\npl = pv.Plotter(shape=(1, 2))\n\npl.subplot(0, 0)\npl.add_mesh(before, show_edges=True)\npl.add_text(\"Before\", font_size=12)\n\npl.subplot(0, 1)\npl.add_mesh(after, show_edges=True)\npl.add_text(\"After\", font_size=12)\n\npl.link_views()\npl.show()\n</code></pre>"},{"location":"tutorials/surface-remeshing/#complete-example","title":"Complete Example","text":"<pre><code>import mmgpy\nfrom mmgpy import MmgSOptions\n\n# Load a mechanical part\nmesh = mmgpy.read(\"mechanical_part.stl\")\n\n# Check initial state\nreport = mesh.validate(detailed=True)\nprint(f\"Initial: {report.n_triangles} triangles, quality={report.quality.mean:.3f}\")\n\n# Configure remeshing\nopts = MmgSOptions(\n    hmin=0.005,\n    hmax=0.05,\n    hausd=0.0005,\n    hgrad=1.2,\n    angle=30.0,\n    verbose=1,\n)\n\n# Remesh\nresult = mesh.remesh(opts)\n\nprint(f\"\\nRemeshed in {result.duration_seconds:.2f}s\")\nprint(f\"Triangles: {result.triangles_before} -&gt; {result.triangles_after}\")\nprint(f\"Quality: {result.quality_mean_before:.3f} -&gt; {result.quality_mean_after:.3f}\")\n\n# Save result\nmesh.save(\"output_surface.vtk\")\n</code></pre>"},{"location":"tutorials/surface-remeshing/#tips-for-surface-remeshing","title":"Tips for Surface Remeshing","text":"<ol> <li>Start conservative: Use small <code>hausd</code> values first to preserve geometry</li> <li>Check quality: Use <code>mesh.validate(detailed=True)</code> to inspect results</li> <li>Ridge preservation: Lower <code>angle</code> values preserve more sharp edges</li> <li>Gradation: Use <code>hgrad</code> close to 1.0 for smoother size transitions</li> <li>Visualization: Always visualize results with PyVista to verify</li> </ol>"},{"location":"tutorials/surface-remeshing/#next-steps","title":"Next Steps","text":"<ul> <li>Adaptive Sizing - Local refinement regions</li> <li>Level-Set Extraction - Extract surfaces from volumes</li> </ul>"}]}